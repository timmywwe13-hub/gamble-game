<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Neon Double-Down - A cyberpunk gambling game. Hack the vault. Beat the odds. Double down on data.">
    <title>Neon Double-Down | Vault Infiltration System v2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(15, 15, 25, 0.95);
            --cyan: #00ffff;
            --cyan-dim: #00aaaa;
            --magenta: #ff00ff;
            --magenta-dim: #aa00aa;
            --yellow: #ffdd00;
            --yellow-dim: #aa9900;
            --green: #00ff88;
            --red: #ff3366;
            --orange: #ff6600;
            --purple: #9933ff;
            --gold: #ffd700;
            --text: #e0e0e0;
            --text-dim: #666;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Binary Code Background Animation */
        .binary-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .binary-column {
            position: absolute;
            top: -100%;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.15);
            animation: fall linear infinite;
            white-space: nowrap;
        }

        @keyframes fall {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(200vh);
            }
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
            z-index: 100;
            font-size: 12px;
        }

        .status-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .status-connected {
            color: var(--green);
        }

        .status-connected::before {
            content: '●';
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .status-center {
            text-align: center;
            color: var(--magenta);
            font-size: 11px;
            letter-spacing: 3px;
        }

        .status-right {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .credits-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--yellow);
            text-shadow: 0 0 10px var(--yellow), 0 0 20px var(--yellow-dim);
        }

        .credits-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 2px;
        }

        /* Screen Container */
        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            padding: 80px 20px 20px;
        }

        .screen.active {
            display: flex;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Main Menu */
        .title-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .title-neon {
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            font-weight: 900;
            color: var(--cyan);
            text-shadow:
                0 0 10px var(--cyan),
                0 0 20px var(--cyan),
                0 0 40px var(--cyan),
                0 0 80px var(--cyan-dim);
            letter-spacing: 8px;
            animation: glowPulse 3s ease-in-out infinite;
        }

        .title-double-down {
            font-family: 'Orbitron', sans-serif;
            font-size: 56px;
            font-weight: 700;
            color: var(--magenta);
            text-shadow:
                0 0 10px var(--magenta),
                0 0 20px var(--magenta),
                0 0 40px var(--magenta),
                0 0 80px var(--magenta-dim);
            letter-spacing: 6px;
            margin-top: -10px;
        }

        @keyframes glowPulse {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.2);
            }
        }

        .tagline {
            color: var(--text-dim);
            font-size: 16px;
            margin-top: 15px;
            letter-spacing: 2px;
        }

        /* Menu Buttons */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 40px;
            width: 100%;
            max-width: 400px;
        }

        .menu-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 3px;
            padding: 18px 40px;
            background: transparent;
            border: 2px solid;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn.cyan {
            color: var(--cyan);
            border-color: var(--cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .menu-btn.cyan:hover {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 20px rgba(0, 255, 255, 0.2);
            transform: scale(1.02);
        }

        .menu-btn.yellow {
            color: var(--yellow);
            border-color: var(--yellow);
            box-shadow: 0 0 10px rgba(255, 221, 0, 0.3), inset 0 0 10px rgba(255, 221, 0, 0.1);
        }

        .menu-btn.yellow:hover {
            background: rgba(255, 221, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.5), inset 0 0 20px rgba(255, 221, 0, 0.2);
            transform: scale(1.02);
        }

        .menu-btn.magenta {
            color: var(--magenta);
            border-color: var(--magenta);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(255, 0, 255, 0.1);
        }

        .menu-btn.magenta:hover {
            background: rgba(255, 0, 255, 0.15);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), inset 0 0 20px rgba(255, 0, 255, 0.2);
            transform: scale(1.02);
        }

        .settings-link {
            margin-top: 30px;
            font-size: 12px;
            color: var(--text-dim);
            cursor: pointer;
            transition: color 0.3s;
        }

        .settings-link:hover {
            color: var(--cyan);
        }

        .press-key {
            margin-top: 20px;
            font-size: 11px;
            color: var(--text-dim);
            letter-spacing: 2px;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {

            0%,
            50%,
            100% {
                opacity: 1;
            }

            25%,
            75% {
                opacity: 0.3;
            }
        }

        /* Game Screen */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        /* ========== 3D NEON DICE ========== */
        .dice-container {
            perspective: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            position: relative;
            min-height: 200px;
        }

        .dice-wrapper {
            perspective: 600px;
            width: 100px;
            height: 100px;
            position: relative;
        }

        .dice-wrapper.single {
            width: 150px;
            height: 150px;
        }

        .dice-wrapper.dice-2 {
            width: 120px;
            height: 120px;
        }

        .dice-wrapper.dice-3 {
            width: 100px;
            height: 100px;
        }

        .dice-wrapper.dice-4 {
            width: 80px;
            height: 80px;
        }

        .dice-scene {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-20deg) rotateY(30deg);
            transition: transform 0.1s ease;
        }

        .dice-scene.rolling {
            animation: diceRoll 2s ease-out;
        }

        @keyframes diceRoll {
            0% {
                transform: rotateX(0deg) rotateY(0deg);
            }

            20% {
                transform: rotateX(360deg) rotateY(180deg);
            }

            40% {
                transform: rotateX(720deg) rotateY(360deg);
            }

            60% {
                transform: rotateX(1080deg) rotateY(540deg);
            }

            80% {
                transform: rotateX(1260deg) rotateY(630deg);
            }

            100% {
                transform: rotateX(var(--final-x)) rotateY(var(--final-y));
            }
        }

        .dice-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid var(--cyan);
            box-shadow:
                0 0 15px rgba(0, 255, 255, 0.3),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            padding: 15%;
            box-sizing: border-box;
        }

        /* Wireframe effect */
        .dice-face::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(90deg, transparent 48%, rgba(0, 255, 255, 0.1) 50%, transparent 52%),
                linear-gradient(0deg, transparent 48%, rgba(0, 255, 255, 0.1) 50%, transparent 52%);
            background-size: 30px 30px;
            pointer-events: none;
        }

        /* Dice face positions - use CSS variable for dynamic sizing */
        .dice-face.front {
            transform: translateZ(var(--dice-half, 75px));
        }

        .dice-face.back {
            transform: rotateY(180deg) translateZ(var(--dice-half, 75px));
        }

        .dice-face.right {
            transform: rotateY(90deg) translateZ(var(--dice-half, 75px));
        }

        .dice-face.left {
            transform: rotateY(-90deg) translateZ(var(--dice-half, 75px));
        }

        .dice-face.top {
            transform: rotateX(90deg) translateZ(var(--dice-half, 75px));
        }

        .dice-face.bottom {
            transform: rotateX(-90deg) translateZ(var(--dice-half, 75px));
        }

        /* Pip colors for each number */
        .pip {
            width: 18%;
            height: 18%;
            border-radius: 50%;
            margin: 3%;
            box-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }

        .pip-1 {
            background: #00ffff;
            color: #00ffff;
        }

        /* Cyan */
        .pip-2 {
            background: #ff00ff;
            color: #ff00ff;
        }

        /* Magenta/Pink */
        .pip-3 {
            background: #00ff88;
            color: #00ff88;
        }

        /* Green */
        .pip-4 {
            background: #ffdd00;
            color: #ffdd00;
        }

        /* Yellow */
        .pip-5 {
            background: #ff3366;
            color: #ff3366;
        }

        /* Red */
        .pip-6 {
            background: #9933ff;
            color: #9933ff;
        }

        /* Purple */

        /* Pip layouts for each face */
        .dice-face[data-value="1"] {
            justify-content: center;
            align-items: center;
        }

        .dice-face[data-value="2"] {
            align-content: space-between;
        }

        .dice-face[data-value="2"] .pip:first-child {
            align-self: flex-start;
        }

        .dice-face[data-value="2"] .pip:last-child {
            align-self: flex-end;
        }

        .dice-face[data-value="3"] {
            align-content: space-between;
        }

        .dice-face[data-value="3"] .pip:nth-child(1) {
            align-self: flex-start;
        }

        .dice-face[data-value="3"] .pip:nth-child(2) {
            align-self: center;
        }

        .dice-face[data-value="3"] .pip:nth-child(3) {
            align-self: flex-end;
        }

        .dice-face[data-value="4"] {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .dice-face[data-value="5"] {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 25px;
        }

        .dice-face[data-value="5"] .pip:nth-child(5) {
            grid-column: 1 / -1;
            justify-self: center;
        }

        .dice-face[data-value="6"] {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 25px;
        }

        /* Color legend */
        .dice-legend {
            position: absolute;
            right: -120px;
            top: 50%;
            transform: translateY(-50%);
            text-align: left;
        }

        .dice-legend-title {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .dice-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .legend-pip {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Win/Lose states for dice */
        .dice-scene.win .dice-face {
            border-color: var(--green);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .dice-scene.lose .dice-face {
            border-color: var(--red);
            box-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
        }

        /* Hide old vault display */
        .vault-display {
            display: none;
        }

        .game-type-label {
            font-size: 14px;
            color: var(--text-dim);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .bet-types {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bet-type-btn {
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--text-dim);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.3s;
        }

        .bet-type-btn:hover {
            border-color: var(--cyan);
            color: var(--cyan);
        }

        .bet-type-btn.active {
            border-color: var(--cyan);
            color: var(--cyan);
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .bet-amounts {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }

        .bet-amount-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 12px 24px;
            background: transparent;
            border: 2px solid var(--yellow);
            color: var(--yellow);
            cursor: pointer;
            transition: all 0.3s;
        }

        .bet-amount-btn:hover {
            background: rgba(255, 221, 0, 0.15);
            box-shadow: 0 0 15px rgba(255, 221, 0, 0.4);
        }

        .bet-amount-btn.active {
            background: rgba(255, 221, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.5);
        }

        .bet-amount-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Overclock & Loaded Dice Buttons */
        .special-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .special-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            padding: 10px 20px;
            border: 2px solid;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 1px;
        }

        .special-btn.overclock {
            color: #ff6600;
            border-color: #ff6600;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.3);
        }

        .special-btn.overclock:hover:not(:disabled) {
            background: rgba(255, 102, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }

        .special-btn.loaded-dice {
            color: #9933ff;
            border-color: #9933ff;
            box-shadow: 0 0 10px rgba(153, 51, 255, 0.3);
        }

        .special-btn.loaded-dice:hover:not(:disabled) {
            background: rgba(153, 51, 255, 0.15);
            box-shadow: 0 0 20px rgba(153, 51, 255, 0.5);
        }

        .special-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .special-btn-cost {
            font-size: 10px;
            opacity: 0.7;
        }

        .action-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 700;
            padding: 15px 40px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
        }

        .action-btn.play {
            background: linear-gradient(135deg, var(--cyan) 0%, var(--cyan-dim) 100%);
            color: var(--bg-dark);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .action-btn.play:hover {
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .action-btn.play:disabled {
            background: var(--text-dim);
            box-shadow: none;
            cursor: not-allowed;
        }

        .action-btn.back {
            background: transparent;
            border: 2px solid var(--text-dim);
            color: var(--text-dim);
        }

        .action-btn.back:hover {
            border-color: var(--magenta);
            color: var(--magenta);
        }

        .current-bet-display {
            margin-top: 20px;
            font-size: 14px;
            color: var(--text-dim);
        }

        .current-bet-display span {
            color: var(--yellow);
            font-weight: bold;
        }

        .result-message {
            margin-top: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .result-message.show {
            opacity: 1;
        }

        .result-message.win {
            color: var(--green);
            text-shadow: 0 0 20px var(--green);
        }

        .result-message.lose {
            color: var(--red);
            text-shadow: 0 0 20px var(--red);
        }

        /* Modal Screens */
        .modal-screen {
            background: var(--bg-panel);
            border: 2px solid var(--cyan);
            border-radius: 10px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--cyan);
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px var(--cyan);
        }

        .modal-content {
            line-height: 1.8;
            font-size: 14px;
        }

        .modal-content h3 {
            color: var(--magenta);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-content ul {
            margin-left: 20px;
        }

        .close-btn {
            display: block;
            margin: 30px auto 0;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 12px 30px;
            background: transparent;
            border: 2px solid var(--cyan);
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        /* Upgrade Shop */
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--text-dim);
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upgrade-item:hover {
            border-color: var(--yellow);
            box-shadow: 0 0 15px rgba(255, 221, 0, 0.2);
        }

        .upgrade-item.owned {
            border-color: var(--green);
            background: rgba(0, 255, 136, 0.05);
        }

        .upgrade-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--cyan);
            margin-bottom: 10px;
        }

        .upgrade-desc {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 10px;
        }

        .upgrade-cost {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: var(--yellow);
        }

        .upgrade-item.owned .upgrade-cost {
            color: var(--green);
        }

        /* Game Over Screen */
        .game-over-container {
            text-align: center;
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            color: var(--red);
            text-shadow: 0 0 30px var(--red);
            margin-bottom: 20px;
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {

            0%,
            100% {
                transform: translate(0);
            }

            20% {
                transform: translate(-2px, 2px);
            }

            40% {
                transform: translate(-2px, -2px);
            }

            60% {
                transform: translate(2px, 2px);
            }

            80% {
                transform: translate(2px, -2px);
            }
        }

        .game-over-message {
            font-size: 18px;
            color: var(--text-dim);
            margin-bottom: 40px;
        }

        /* Settings */
        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-label {
            font-size: 14px;
        }

        .toggle-switch {
            width: 50px;
            height: 26px;
            background: var(--text-dim);
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--cyan);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 26px;
        }

        /* Access Level Progress */
        .access-progress {
            width: 100%;
            max-width: 400px;
            margin-top: 30px;
        }

        .access-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .access-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cyan), var(--magenta));
            transition: width 0.5s ease;
        }

        .access-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            color: var(--text-dim);
        }

        .access-label.current {
            color: var(--cyan);
        }

        /* ========== REBIRTH SYSTEM ========== */
        .rebirth-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            text-align: center;
        }

        .rebirth-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            padding: 6px 16px;
            background: linear-gradient(135deg, #ffd700, #ff6600);
            border-radius: 20px;
            color: #0a0a0f;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .rebirth-badge.hidden {
            display: none;
        }

        .rebirth-badge .rebirth-icon {
            font-size: 16px;
        }

        .rebirth-stars {
            display: flex;
            gap: 3px;
        }

        .rebirth-star {
            font-size: 10px;
            color: #0a0a0f;
        }

        .rebirth-star.empty {
            opacity: 0.3;
        }

        /* Vault Break Button */
        .vault-break-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            padding: 12px 30px;
            background: linear-gradient(135deg, #ffd700 0%, #ff6600 50%, #ff3366 100%);
            border: none;
            color: #0a0a0f;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            margin-top: 15px;
            display: none;
            animation: vaultPulse 1.5s ease infinite;
        }

        .vault-break-btn.show {
            display: inline-block;
        }

        .vault-break-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
        }

        @keyframes vaultPulse {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.4), 0 0 40px rgba(255, 102, 0, 0.3);
            }

            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 102, 0, 0.5);
            }
        }

        /* Vault Break Animation Overlay */
        .vault-break-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 250;
            display: none;
        }

        .vault-break-effect.active {
            display: block;
            animation: vaultBreakFlash 2s ease forwards;
        }

        @keyframes vaultBreakFlash {
            0% {
                background: transparent;
            }

            15% {
                background: rgba(255, 215, 0, 0.8);
            }

            30% {
                background: rgba(255, 102, 0, 0.6);
            }

            50% {
                background: rgba(255, 51, 102, 0.4);
            }

            70% {
                background: rgba(0, 255, 255, 0.3);
            }

            100% {
                background: transparent;
            }
        }

        /* ========== NEW FEATURES CSS ========== */

        /* Win Streak Display */
        .streak-display {
            position: fixed;
            top: 80px;
            right: 20px;
            text-align: right;
            z-index: 99;
        }

        .streak-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .streak-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            font-weight: 700;
            color: var(--orange);
            text-shadow: 0 0 10px var(--orange);
        }

        .streak-value.hot {
            color: var(--gold);
            text-shadow: 0 0 20px var(--gold), 0 0 40px var(--orange);
            animation: fireGlow 0.5s ease infinite alternate;
        }

        @keyframes fireGlow {
            from {
                filter: brightness(1);
            }

            to {
                filter: brightness(1.3);
            }
        }

        /* Daily Bonus Banner */
        .daily-bonus-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 3px solid var(--gold);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.4);
            animation: popIn 0.5s ease;
            display: none;
        }

        .daily-bonus-banner.show {
            display: block;
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .daily-bonus-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--gold);
            text-shadow: 0 0 20px var(--gold);
            margin-bottom: 15px;
        }

        .daily-bonus-amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: var(--yellow);
            text-shadow: 0 0 30px var(--yellow);
            margin-bottom: 20px;
        }

        /* Critical Hit Effect */
        .critical-hit {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 0 30px var(--gold), 0 0 60px var(--orange);
            z-index: 150;
            animation: criticalPop 1s ease forwards;
            pointer-events: none;
            display: none;
        }

        @keyframes criticalPop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }

            30% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        /* Insurance Toggle */
        .insurance-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-dim);
        }

        .insurance-toggle.active {
            color: var(--green);
        }

        .insurance-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--text-dim);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .insurance-checkbox.active {
            border-color: var(--green);
            background: rgba(0, 255, 136, 0.2);
        }

        .insurance-checkbox.active::after {
            content: '✓';
            color: var(--green);
            font-size: 14px;
        }

        /* Jackpot Mode */
        .jackpot-mode-btn {
            margin-top: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 12px 25px;
            background: linear-gradient(135deg, var(--gold) 0%, var(--orange) 100%);
            border: none;
            color: var(--bg-dark);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .jackpot-mode-btn:hover {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            transform: scale(1.05);
        }

        .jackpot-mode-btn.active {
            animation: jackpotPulse 1s ease infinite;
        }

        @keyframes jackpotPulse {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            }

            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            }
        }

        /* Achievements Panel */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .achievement-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--text-dim);
            padding: 15px;
            text-align: center;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .achievement-item.unlocked {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }

        .achievement-icon {
            font-size: 32px;
            margin-bottom: 8px;
            filter: grayscale(100%);
            opacity: 0.3;
        }

        .achievement-item.unlocked .achievement-icon {
            filter: none;
            opacity: 1;
        }

        .achievement-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .achievement-item.unlocked .achievement-name {
            color: var(--gold);
        }

        .achievement-desc {
            font-size: 9px;
            color: var(--text-dim);
        }

        /* Combo Multiplier */
        .combo-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 99;
        }

        .combo-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .combo-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--purple);
            text-shadow: 0 0 15px var(--purple);
        }

        /* Particle Container */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: particleFall 1.5s ease forwards;
        }

        @keyframes particleFall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Floating Text */
        .floating-text {
            position: fixed;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            pointer-events: none;
            z-index: 160;
            animation: floatUp 1.5s ease forwards;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        /* Mystery Box */
        .mystery-box {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 20px auto;
            background: linear-gradient(135deg, var(--purple) 0%, var(--magenta) 100%);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            box-shadow: 0 0 30px rgba(153, 51, 255, 0.4);
            transition: all 0.3s;
            animation: mysteryFloat 2s ease-in-out infinite;
        }

        .mystery-box:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(153, 51, 255, 0.6);
        }

        @keyframes mysteryFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* Notification Toast */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-panel);
            border: 2px solid var(--cyan);
            padding: 15px 30px;
            border-radius: 8px;
            z-index: 200;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Achievements Button */
        .menu-btn.gold {
            color: var(--gold);
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3), inset 0 0 10px rgba(255, 215, 0, 0.1);
        }

        .menu-btn.gold:hover {
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), inset 0 0 20px rgba(255, 215, 0, 0.2);
            transform: scale(1.02);
        }

        /* Love Page Button */
        .menu-btn.pink {
            color: #ff69b4;
            border-color: #ff69b4;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3), inset 0 0 10px rgba(255, 105, 180, 0.1);
        }

        .menu-btn.pink:hover {
            background: rgba(255, 105, 180, 0.15);
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5), inset 0 0 20px rgba(255, 105, 180, 0.2);
            transform: scale(1.02);
        }

        /* ========== SYSTEM OVERLOAD (ULTIMATE MOVE) ========== */
        .ultimate-meter {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 200px;
            z-index: 99;
        }

        .ultimate-meter-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .ultimate-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--cyan);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .ultimate-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #ffdd00);
            background-size: 200% 100%;
            animation: ultimateGradient 2s linear infinite;
            transition: width 0.3s ease;
        }

        @keyframes ultimateGradient {
            0% {
                background-position: 0% 0%;
            }

            100% {
                background-position: 200% 0%;
            }
        }

        .ultimate-btn {
            margin-top: 8px;
            width: 100%;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            padding: 10px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            border: none;
            color: var(--bg-dark);
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .ultimate-btn:disabled {
            background: var(--text-dim);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .ultimate-btn:not(:disabled):hover {
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), 0 0 30px rgba(255, 0, 255, 0.6);
            transform: scale(1.05);
        }

        .ultimate-btn.ready {
            animation: ultimatePulse 0.5s ease infinite alternate;
        }

        @keyframes ultimatePulse {
            from {
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 20px rgba(255, 0, 255, 0.4);
            }

            to {
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.8);
            }
        }

        .system-overload-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3), transparent);
            animation: overloadFlash 0.5s ease forwards;
            display: none;
        }

        @keyframes overloadFlash {
            0% {
                opacity: 1;
                transform: scale(0);
            }

            50% {
                opacity: 1;
                transform: scale(2);
            }

            100% {
                opacity: 0;
                transform: scale(3);
            }
        }

        /* ========== HEAT LEVEL (DYNAMIC DIFFICULTY) ========== */
        .heat-display {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 99;
        }

        .heat-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .heat-bar {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .heat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffdd00, #ff6600, #ff3366);
            transition: width 0.5s ease;
        }

        .heat-level-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            margin-top: 5px;
        }

        .heat-level-text.ice {
            color: #00ffff;
        }

        .heat-level-text.cool {
            color: #00ff88;
        }

        .heat-level-text.warm {
            color: #ffdd00;
        }

        .heat-level-text.hot {
            color: #ff6600;
        }

        .heat-level-text.inferno {
            color: #ff3366;
            text-shadow: 0 0 10px #ff3366;
        }

        /* ========== CHARACTER CLASSES ========== */
        .class-display {
            position: fixed;
            top: 150px;
            left: 20px;
            z-index: 99;
            text-align: center;
        }

        .class-icon {
            font-size: 36px;
            margin-bottom: 5px;
        }

        .class-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--cyan);
            letter-spacing: 1px;
        }

        .class-ability {
            font-size: 10px;
            color: var(--text-dim);
            max-width: 100px;
        }

        /* Class Selection Modal */
        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .class-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid var(--text-dim);
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .class-card:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transform: translateY(-5px);
        }

        .class-card.selected {
            border-color: var(--magenta);
            background: rgba(255, 0, 255, 0.1);
        }

        .class-card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .class-card-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--cyan);
            margin-bottom: 8px;
        }

        .class-card-ability {
            font-size: 11px;
            color: var(--text-dim);
        }

        /* ========== END OF RUN REWARDS ========== */
        .end-run-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 3px solid var(--gold);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.4);
            animation: popIn 0.5s ease;
            display: none;
            max-width: 500px;
            width: 90%;
        }

        .end-run-modal.show {
            display: block;
        }

        .end-run-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--gold);
            text-shadow: 0 0 20px var(--gold);
            margin-bottom: 20px;
        }

        .end-run-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .end-run-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .end-run-stat-label {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .end-run-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: var(--cyan);
        }

        .end-run-rewards {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid var(--gold);
            border-radius: 10px;
        }

        .end-run-rewards-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: var(--gold);
            margin-bottom: 15px;
        }

        .reward-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        .reward-item:last-child {
            border-bottom: none;
        }

        .reward-label {
            color: var(--text);
        }

        .reward-value {
            color: var(--yellow);
            font-weight: bold;
        }

        /* ========== LOVE PAGE ========== */
        .love-screen {
            background: linear-gradient(135deg, #1a0a1a 0%, #0a0a15 50%, #1a0a1a 100%);
        }

        .love-container {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .love-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            color: #ff69b4;
            text-shadow: 0 0 30px #ff69b4, 0 0 60px #ff1493;
            margin-bottom: 30px;
            animation: heartPulse 1.5s ease infinite;
        }

        @keyframes heartPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .love-message {
            font-size: 18px;
            line-height: 2;
            color: var(--text);
            margin-bottom: 30px;
        }

        .flower-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }

        .flower {
            font-size: 48px;
            animation: flowerSway 2s ease-in-out infinite;
        }

        .flower:nth-child(2) {
            animation-delay: 0.3s;
        }

        .flower:nth-child(3) {
            animation-delay: 0.6s;
        }

        .flower:nth-child(4) {
            animation-delay: 0.9s;
        }

        .flower:nth-child(5) {
            animation-delay: 1.2s;
        }

        @keyframes flowerSway {

            0%,
            100% {
                transform: rotate(-5deg);
            }

            50% {
                transform: rotate(5deg);
            }
        }

        .hearts-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        .floating-heart {
            position: absolute;
            font-size: 24px;
            animation: floatHeart 10s linear infinite;
            opacity: 0.6;
        }

        @keyframes floatHeart {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.6;
            }

            90% {
                opacity: 0.6;
            }

            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* ========== RESPONSIVE DESIGN ========== */

        /* Tablet / Small Laptop Breakpoint */
        @media (max-width: 768px) {
            .title-neon {
                font-size: 48px;
                letter-spacing: 4px;
            }

            .title-double-down {
                font-size: 36px;
                letter-spacing: 3px;
            }

            .tagline {
                font-size: 14px;
            }

            .status-bar {
                padding: 8px 15px;
                font-size: 10px;
            }

            .status-center {
                font-size: 9px;
                letter-spacing: 1px;
            }

            .credits-display {
                font-size: 18px;
            }

            .menu-buttons {
                max-width: 320px;
                gap: 12px;
            }

            .menu-btn {
                font-size: 14px;
                padding: 14px 30px;
                letter-spacing: 2px;
            }

            .dice-container {
                width: 160px;
                height: 160px;
            }

            .dice-scene {
                width: 120px;
                height: 120px;
            }

            .dice-face {
                width: 120px;
                height: 120px;
            }

            .dice-face.front {
                transform: translateZ(60px);
            }

            .dice-face.back {
                transform: rotateY(180deg) translateZ(60px);
            }

            .dice-face.right {
                transform: rotateY(90deg) translateZ(60px);
            }

            .dice-face.left {
                transform: rotateY(-90deg) translateZ(60px);
            }

            .dice-face.top {
                transform: rotateX(90deg) translateZ(60px);
            }

            .dice-face.bottom {
                transform: rotateX(-90deg) translateZ(60px);
            }

            .pip {
                width: 16px;
                height: 16px;
            }

            .dice-legend {
                display: none;
            }

            .streak-display {
                top: 70px;
                right: 10px;
            }

            .streak-value {
                font-size: 16px;
            }

            .heat-display {
                top: 70px;
                left: 10px;
            }

            .heat-bar {
                width: 100px;
            }

            .heat-level-text {
                font-size: 12px;
            }

            .class-display {
                top: 130px;
                left: 10px;
            }

            .class-icon {
                font-size: 28px;
            }

            .class-name {
                font-size: 10px;
            }

            .class-ability {
                font-size: 8px;
                max-width: 80px;
            }

            .ultimate-meter {
                bottom: 60px;
                right: 10px;
                width: 150px;
            }

            .ultimate-meter-label {
                font-size: 8px;
            }

            .ultimate-btn {
                font-size: 10px;
                padding: 8px;
            }

            .combo-display {
                bottom: 10px;
                left: 10px;
            }

            .combo-value {
                font-size: 18px;
            }

            .bet-type-btn {
                font-size: 11px;
                padding: 8px 15px;
            }

            .bet-amount-btn {
                font-size: 12px;
                padding: 10px 18px;
            }

            .action-btn {
                font-size: 14px;
                padding: 12px 30px;
            }

            .special-btn {
                font-size: 10px;
                padding: 8px 15px;
            }

            .modal-screen {
                padding: 25px;
                width: 95%;
            }

            .modal-title {
                font-size: 22px;
            }

            .game-over-title {
                font-size: 36px;
            }

            .upgrade-grid {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            }

            .achievements-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .class-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .end-run-modal {
                padding: 25px;
            }

            .end-run-title {
                font-size: 22px;
            }

            .love-title {
                font-size: 28px;
            }

            .love-message {
                font-size: 16px;
            }
        }

        /* Mobile Breakpoint */
        @media (max-width: 480px) {
            .title-neon {
                font-size: 32px;
                letter-spacing: 2px;
            }

            .title-double-down {
                font-size: 24px;
                letter-spacing: 1px;
                margin-top: -5px;
            }

            .tagline {
                font-size: 12px;
                letter-spacing: 1px;
            }

            .status-bar {
                padding: 6px 10px;
                font-size: 9px;
                flex-wrap: wrap;
                gap: 5px;
            }

            .status-center {
                display: none;
            }

            .credits-display {
                font-size: 16px;
            }

            .screen {
                padding: 60px 10px 10px;
            }

            .menu-buttons {
                max-width: 280px;
                gap: 10px;
            }

            .menu-btn {
                font-size: 12px;
                padding: 12px 20px;
                letter-spacing: 1px;
            }

            .dice-container {
                width: 130px;
                height: 130px;
                margin-bottom: 20px;
            }

            .dice-scene {
                width: 100px;
                height: 100px;
                margin: 15px auto;
            }

            .dice-face {
                width: 100px;
                height: 100px;
                padding: 15px;
            }

            .dice-face.front {
                transform: translateZ(50px);
            }

            .dice-face.back {
                transform: rotateY(180deg) translateZ(50px);
            }

            .dice-face.right {
                transform: rotateY(90deg) translateZ(50px);
            }

            .dice-face.left {
                transform: rotateY(-90deg) translateZ(50px);
            }

            .dice-face.top {
                transform: rotateX(90deg) translateZ(50px);
            }

            .dice-face.bottom {
                transform: rotateX(-90deg) translateZ(50px);
            }

            .pip {
                width: 12px;
                height: 12px;
                margin: 3px;
            }

            .dice-face[data-value="4"] {
                gap: 20px;
                padding: 20px;
            }

            .dice-face[data-value="5"] {
                gap: 12px;
                padding: 18px;
            }

            .dice-face[data-value="6"] {
                gap: 10px;
                padding: 18px;
            }

            .streak-display {
                top: auto;
                bottom: 140px;
                right: 10px;
            }

            .ultimate-meter {
                bottom: 60px;
                right: 10px;
                width: 130px;
                padding: 10px;
            }

            .ultimate-meter-label {
                font-size: 8px;
            }

            .ultimate-btn {
                font-size: 9px;
                padding: 6px;
            }

            .heat-display {
                top: auto;
                bottom: 140px;
                left: 10px;
            }

            .game-container {
                padding-bottom: 150px;
                /* Prevent fixed elements overlap */
            }

            .rebirth-badge {
                font-size: 10px;
                padding: 4px 10px;
                max-width: 90%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Compact status bar for mobile */
            .status-bar {
                padding: 4px 8px;
                gap: 5px;
                font-size: 8px;
            }

            .status-center {
                display: none;
                /* Hide center text on mobile to save space */
            }

            .heat-label {
                font-size: 8px;
            }

            .heat-bar {
                width: 80px;
                height: 6px;
            }

            .heat-level-text {
                font-size: 10px;
            }

            .class-display {
                display: none;
            }

            .ultimate-meter {
                bottom: 10px;
                right: 10px;
                left: 10px;
                width: auto;
            }

            .ultimate-bar {
                height: 10px;
            }

            .ultimate-btn {
                font-size: 11px;
                padding: 10px;
                min-height: 44px;
            }

            .combo-display {
                display: none;
            }

            .bet-types {
                gap: 6px;
            }

            .bet-type-btn {
                font-size: 10px;
                padding: 8px 12px;
                min-height: 44px;
            }

            .bet-amounts {
                gap: 6px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .bet-amount-btn {
                font-size: 11px;
                padding: 10px 14px;
                min-height: 44px;
            }

            .action-buttons {
                gap: 10px;
            }

            .action-btn {
                font-size: 12px;
                padding: 12px 25px;
                min-height: 48px;
            }

            .special-actions {
                gap: 6px;
            }

            .special-btn {
                font-size: 9px;
                padding: 8px 12px;
                min-height: 44px;
            }

            .modal-screen {
                padding: 20px;
                max-height: 90vh;
            }

            .modal-title {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .modal-content {
                font-size: 12px;
            }

            .close-btn {
                font-size: 12px;
                padding: 12px 25px;
                min-height: 44px;
            }

            .game-over-title {
                font-size: 28px;
            }

            .game-over-message {
                font-size: 14px;
            }

            .upgrade-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .upgrade-item {
                padding: 15px;
            }

            .upgrade-name {
                font-size: 12px;
            }

            .upgrade-desc {
                font-size: 10px;
            }

            .upgrade-cost {
                font-size: 14px;
            }

            .achievements-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 8px;
            }

            .achievement-item {
                padding: 10px;
            }

            .achievement-icon {
                font-size: 24px;
            }

            .achievement-name {
                font-size: 9px;
            }

            .achievement-desc {
                font-size: 8px;
            }

            .class-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .class-card {
                padding: 15px;
            }

            .class-card-icon {
                font-size: 36px;
            }

            .class-card-name {
                font-size: 12px;
            }

            .class-card-ability {
                font-size: 10px;
            }

            .daily-bonus-banner {
                padding: 25px;
                width: 90%;
            }

            .daily-bonus-title {
                font-size: 20px;
            }

            .daily-bonus-amount {
                font-size: 36px;
            }

            .end-run-modal {
                padding: 20px;
            }

            .end-run-title {
                font-size: 18px;
            }

            .end-run-stats {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .end-run-stat {
                padding: 10px;
            }

            .end-run-stat-label {
                font-size: 8px;
            }

            .end-run-stat-value {
                font-size: 16px;
            }

            .end-run-rewards {
                padding: 15px;
            }

            .end-run-rewards-title {
                font-size: 14px;
            }

            .love-container {
                padding: 20px;
            }

            .love-title {
                font-size: 22px;
            }

            .love-message {
                font-size: 14px;
                line-height: 1.8;
            }

            .flower {
                font-size: 36px;
            }

            .critical-hit {
                font-size: 48px;
            }

            .toast {
                padding: 12px 20px;
                font-size: 12px;
                left: 10px;
                right: 10px;
                transform: translateX(0) translateY(100px);
                width: auto;
            }

            .toast.show {
                transform: translateX(0) translateY(0);
            }

            .jackpot-mode-btn {
                font-size: 12px;
                padding: 10px 20px;
                min-height: 44px;
            }

            .insurance-toggle {
                font-size: 11px;
            }

            .insurance-checkbox {
                width: 24px;
                height: 24px;
            }

            .result-message {
                font-size: 18px;
            }

            .current-bet-display {
                font-size: 12px;
            }

            .access-progress {
                max-width: 280px;
            }
        }

        /* Extra small devices */
        @media (max-width: 360px) {
            .title-neon {
                font-size: 26px;
            }

            .title-double-down {
                font-size: 20px;
            }

            .menu-btn {
                font-size: 11px;
                padding: 10px 15px;
            }

            .bet-type-btn {
                font-size: 9px;
                padding: 6px 10px;
            }

            .bet-amount-btn {
                font-size: 10px;
                padding: 8px 12px;
            }

            .upgrade-grid {
                grid-template-columns: 1fr;
            }

            .class-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Map Themes */
        body.cyber-theme .binary-bg {
            color: rgba(255, 215, 0, 0.15);
        }

        body.cyber-theme .screen {
            border-color: var(--yellow);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }

        body.cyber-theme .dice-face {
            border-color: var(--yellow);
            box-shadow: 0 0 10px var(--yellow);
        }

        body.cyber-theme .pip {
            background: var(--yellow);
            box-shadow: 0 0 5px var(--yellow);
        }

        body.void-theme .binary-bg {
            color: rgba(255, 0, 51, 0.15);
        }

        body.void-theme .screen {
            border-color: var(--red);
            box-shadow: 0 0 20px rgba(255, 0, 51, 0.2);
        }

        body.void-theme .dice-face {
            border-color: var(--red);
            box-shadow: 0 0 10px var(--red);
        }

        body.void-theme .pip {
            background: var(--red);
            box-shadow: 0 0 5px var(--red);
        }

        .map-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .map-card {
            padding: 15px;
            border: 1px solid var(--text-dim);
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: all 0.3s;
        }

        .map-card:hover {
            border-color: var(--cyan);
            background: rgba(0, 255, 255, 0.1);
        }

        .map-card.selected {
            border-color: var(--green);
            box-shadow: 0 0 15px var(--green);
        }

        .map-card.cyber {
            border-left: 5px solid var(--yellow);
        }

        .map-card.void {
            border-left: 5px solid var(--red);
        }
    </style>
</head>

<body>
    <!-- Binary Code Background -->
    <div class="binary-bg" id="binaryBg"></div>

    <!-- Particle Effects Container -->
    <div class="particles" id="particles"></div>

    <!-- Critical Hit Effect -->
    <div class="critical-hit" id="criticalHit">CRITICAL!</div>

    <!-- Daily Bonus Banner -->
    <div class="daily-bonus-banner" id="dailyBonusBanner">
        <div class="daily-bonus-title">⚡ DAILY BONUS ⚡</div>
        <div class="daily-bonus-amount" id="dailyBonusAmount">+500</div>
        <button class="menu-btn cyan" id="claimBonusBtn">CLAIM CHIPS</button>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- System Overload Effect -->
    <div class="system-overload-effect" id="systemOverloadEffect"></div>

    <!-- Vault Break Effect -->
    <div class="vault-break-effect" id="vaultBreakEffect"></div>

    <!-- Rebirth Display -->
    <div class="rebirth-display" id="rebirthDisplay">
        <div class="rebirth-badge hidden" id="rebirthBadge">
            <span class="rebirth-icon">🔥</span>
            <span>REBIRTH</span>
            <div class="rebirth-stars" id="rebirthStars"></div>
        </div>
    </div>

    <!-- Ultimate Meter (System Overload) -->
    <div class="ultimate-meter" id="ultimateMeter" style="display: none;">
        <div class="ultimate-meter-label">
            <span>⚡ SYSTEM OVERLOAD</span>
            <span id="ultimatePercent">0%</span>
        </div>
        <div class="ultimate-bar">
            <div class="ultimate-fill" id="ultimateFill" style="width: 0%"></div>
        </div>
        <button class="ultimate-btn" id="ultimateBtn" disabled>ACTIVATE OVERLOAD</button>
    </div>

    <!-- Heat Level Display -->
    <div class="heat-display" id="heatDisplay">
        <div class="heat-label">🌡️ HEAT LEVEL</div>
        <div class="heat-bar">
            <div class="heat-fill" id="heatFill" style="width: 20%"></div>
        </div>
        <div class="heat-level-text cool" id="heatLevelText">COOL</div>
    </div>

    <!-- Character Class Display -->
    <div class="class-display" id="classDisplay">
        <div class="class-icon" id="classIcon">🎮</div>
        <div class="class-name" id="className">GAMBLER</div>
        <div class="class-ability" id="classAbility">Standard Play</div>
    </div>

    <!-- End of Run Modal -->
    <div class="end-run-modal" id="endRunModal">
        <div class="end-run-title">🎰 RUN COMPLETE 🎰</div>
        <div class="end-run-stats">
            <div class="end-run-stat">
                <div class="end-run-stat-label">TOTAL WINS</div>
                <div class="end-run-stat-value" id="endRunWins">0</div>
            </div>
            <div class="end-run-stat">
                <div class="end-run-stat-label">TOTAL LOSSES</div>
                <div class="end-run-stat-value" id="endRunLosses">0</div>
            </div>
            <div class="end-run-stat">
                <div class="end-run-stat-label">MAX STREAK</div>
                <div class="end-run-stat-value" id="endRunStreak">0</div>
            </div>
            <div class="end-run-stat">
                <div class="end-run-stat-label">CHIPS EARNED</div>
                <div class="end-run-stat-value" id="endRunChips">0</div>
            </div>
        </div>
        <div class="end-run-rewards">
            <div class="end-run-rewards-title">✨ RUN REWARDS ✨</div>
            <div id="endRunRewardsList"></div>
        </div>
        <button class="menu-btn cyan" id="claimRunRewardsBtn">CLAIM REWARDS</button>
    </div>

    <!-- Win Streak Display -->
    <div class="streak-display" id="streakDisplay">
        <div class="streak-label">WIN STREAK</div>
        <div class="streak-value" id="streakValue">0🔥</div>
    </div>

    <!-- Combo Multiplier Display -->
    <div class="combo-display" id="comboDisplay">
        <div class="combo-label">COMBO</div>
        <div class="combo-value" id="comboValue">x1.0</div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-left">
            <div class="status-connected">STATUS: CONNECTED</div>
            <div id="timeDisplay">TIME: --:--:--</div>
            <div>ACCESS LEVEL: <span id="accessLevel">RECRUIT</span></div>
        </div>
        <div class="status-center">VAULT INFILTRATION SYSTEM v2.0</div>
        <div class="status-right">
            <div class="credits-label">CREDITS</div>
            <div class="credits-display" id="creditsDisplay">1,250</div>
        </div>
    </div>

    <!-- Main Menu Screen -->
    <div class="screen active" id="menuScreen">
        <div class="title-container">
            <div class="title-neon">NEON</div>
            <div class="title-double-down">DOUBLE DOWN</div>
            <div class="tagline">Hack the vault. Beat the odds. Double down on data.</div>
        </div>

        <div class="menu-buttons">
            <button class="menu-btn cyan" id="startRunBtn">START RUN</button>
            <button class="menu-btn yellow" id="howToPlayBtn">HOW TO PLAY</button>
            <button class="menu-btn magenta" id="upgradeShopBtn">UPGRADE SHOP</button>
            <button class="menu-btn gold" id="achievementsBtn">🏆 ACHIEVEMENTS</button>
            <button class="menu-btn cyan" id="classSelectBtn">🎭 SELECT CLASS</button>
            <button class="menu-btn green" id="mapSelectBtn">🗺️ SELECT MAP</button>
            <button class="menu-btn pink" id="lovePageBtn">💕 SPECIAL MESSAGE</button>
            <button class="menu-btn magenta" id="updatesBtn">📝 UPDATES</button>
        </div>

        <!-- Mystery Box (appears when available) -->
        <div class="mystery-box" id="mysteryBox" style="display: none;">📦</div>

        <div class="press-key">PRESS ANY KEY TO BEGIN HACK SEQUENCE</div>
        <div class="settings-link" id="settingsBtn">DATACORE SETTINGS | 2077</div>
    </div>

    <!-- Game Screen -->
    <div class="screen" id="gameScreen">
        <div class="game-container">
            <!-- 3D Dice Display - Dynamically populated based on access level -->
            <div class="dice-container" id="diceContainer">
                <!-- Dice will be dynamically generated by JavaScript -->
            </div>

            <!-- Old Vault Display (Hidden via CSS) -->
            <div class="vault-display" id="vaultDisplay" style="display: none;">
                <span class="vault-value" id="vaultValue">?</span>
            </div>

            <div class="game-type-label">SELECT BET TYPE</div>
            <div class="bet-types">
                <button class="bet-type-btn active" data-type="double">DOUBLE OR NOTHING</button>
                <button class="bet-type-btn" data-type="highlow">HIGH / LOW</button>
                <button class="bet-type-btn" data-type="triple">TRIPLE THREAT</button>
            </div>

            <div class="game-type-label">SELECT BET AMOUNT</div>
            <div class="bet-amounts">
                <button class="bet-amount-btn active" data-amount="100">100</button>
                <button class="bet-amount-btn" data-amount="250">250</button>
                <button class="bet-amount-btn" data-amount="500">500</button>
                <button class="bet-amount-btn" data-amount="all">ALL IN</button>
            </div>

            <div class="action-buttons">
                <button class="action-btn back" id="backToMenuBtn">← ABORT</button>
                <button class="action-btn play" id="playBtn">EXECUTE HACK</button>
            </div>

            <div class="special-actions">
                <button class="special-btn overclock" id="overclockBtn" disabled>
                    ⟳ OVERCLOCK <span class="special-btn-cost">(50 chips)</span>
                </button>
                <button class="special-btn loaded-dice" id="loadedDiceBtn" disabled>
                    🎲 LOADED DICE <span class="special-btn-cost">(flip result)</span>
                </button>
            </div>

            <div class="current-bet-display">
                Current Bet: <span id="currentBetDisplay">100</span> chips |
                Win Multiplier: <span id="multiplierDisplay">2x</span>
            </div>

            <div class="result-message" id="resultMessage"></div>

            <div class="access-progress">
                <div class="access-bar">
                    <div class="access-fill" id="accessFill" style="width: 0%"></div>
                </div>
                <div class="access-labels">
                    <span class="access-label current">RECRUIT</span>
                    <span class="access-label">HACKER</span>
                    <span class="access-label">ELITE</span>
                    <span class="access-label">ADMIN</span>
                </div>
            </div>

            <!-- Vault Break Button (appears at ADMIN level) -->
            <button class="vault-break-btn" id="vaultBreakBtn">🔓 BREAK INTO VAULT 🔓</button>
        </div>
    </div>

    <!-- How To Play Screen -->
    <div class="screen" id="howToPlayScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// HOW TO PLAY //</h2>
            <div class="modal-content">
                <h3>⟨ OBJECTIVE ⟩</h3>
                <p>You're a data gambler infiltrating a high-security vault. Win Energy Chips by betting on randomized
                    outcomes to reach ADMIN access level and crack the vault.</p>

                <h3>⟨ BET TYPES ⟩</h3>
                <ul>
                    <li><strong>Double or Nothing</strong> - 50% chance, 2x payout</li>
                    <li><strong>High / Low</strong> - Guess if the number is high (5-9) or low (0-4), 2x payout</li>
                    <li><strong>Triple Threat</strong> - Pick from 3 options, 3x payout (33% chance)</li>
                </ul>

                <h3>⟨ STRATEGIC ABILITIES ⟩</h3>
                <ul>
                    <li><strong style="color: #ff6600;">OVERCLOCK</strong> - Spend 50 chips to re-roll after a loss.
                        This is where strategy kicks in!</li>
                    <li><strong style="color: #9933ff;">LOADED DICE</strong> - Once per round, flip your result (loss →
                        win, win → loss). Requires upgrade.</li>
                </ul>

                <h3>⟨ PROGRESSION ⟩</h3>
                <ul>
                    <li><strong>RECRUIT</strong> → 0 chips (Starting level)</li>
                    <li><strong>HACKER</strong> → 5,000 chips</li>
                    <li><strong>ELITE</strong> → 25,000 chips</li>
                    <li><strong>ADMIN</strong> → 100,000 chips (VAULT CRACKED!)</li>
                </ul>

                <h3>⟨ WARNING ⟩</h3>
                <p style="color: var(--red);">If you lose all your chips, connection will be terminated and you'll
                    restart from the lobby with base chips.</p>
            </div>
            <button class="close-btn" id="closeHowToPlay">CLOSE TERMINAL</button>
        </div>
    </div>

    <!-- Upgrade Shop Screen -->
    <div class="screen" id="upgradeShopScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// UPGRADE SHOP //</h2>
            <div class="upgrade-grid" id="upgradeGrid">
                <!-- Upgrades populated by JS -->
            </div>
            <button class="close-btn" id="closeUpgradeShop">CLOSE SHOP</button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div class="screen" id="settingsScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// SETTINGS //</h2>
            <div class="modal-content">
                <div class="settings-option">
                    <span class="settings-label">Sound Effects</span>
                    <div class="toggle-switch active" id="toggleSound"></div>
                </div>
                <div class="settings-option">
                    <span class="settings-label">Binary Background</span>
                    <div class="toggle-switch active" id="toggleBinary"></div>
                </div>
                <div class="settings-option">
                    <span class="settings-label">Animations</span>
                    <div class="toggle-switch active" id="toggleAnimations"></div>
                </div>
                <div class="settings-option">
                    <span class="settings-label">Reset Progress</span>
                    <button class="close-btn" style="margin: 0; padding: 8px 20px;" id="resetProgress">RESET</button>
                </div>
            </div>
            <button class="close-btn" id="closeSettings">SAVE & CLOSE</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div class="screen" id="gameOverScreen">
        <div class="game-over-container">
            <div class="game-over-title">CONNECTION LOST</div>
            <div class="game-over-message">Your chips have been depleted. Security protocols engaged.</div>
            <button class="menu-btn cyan" id="restartBtn">RECONNECT TO LOBBY</button>
        </div>
    </div>

    <!-- Achievements Screen -->
    <div class="screen" id="achievementsScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// ACHIEVEMENTS //</h2>
            <div class="achievements-grid" id="achievementsGrid">
                <!-- Populated by JS -->
            </div>
            <button class="close-btn" id="closeAchievements">CLOSE</button>
        </div>
    </div>

    <!-- Class Selection Screen -->
    <div class="screen" id="classSelectScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// SELECT CLASS //</h2>
            <p style="color: var(--text-dim); text-align: center; margin-bottom: 20px;">
                Choose your hacker class. Each class has a unique ability!
            </p>
            <div class="class-grid" id="classGrid">
                <!-- Populated by JS -->
            </div>
            <button class="close-btn" id="closeClassSelect">CONFIRM</button>
        </div>
    </div>

    <!-- Map Selection Screen -->
    <div class="screen" id="mapSelectScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// SELECT SECTOR //</h2>
            <p style="color: var(--text-dim); text-align: center; margin-bottom: 20px;">
                Choose your operation zone. Different zones have different environmental effects.
            </p>
            <div class="map-grid" id="mapGrid">
                <!-- Populated by JS -->
            </div>
            <button class="close-btn" id="closeMapSelect">CONFIRM</button>
        </div>
    </div>

    <!-- Updates Screen -->
    <div class="screen" id="updatesScreen">
        <div class="modal-screen">
            <h2 class="modal-title">// SYSTEM UPDATES //</h2>
            <div id="updatesList" style="text-align: left; max-height: 400px; overflow-y: auto; padding: 10px;">
                <!-- Populated by JS -->
            </div>
            <button class="close-btn" id="closeUpdates">CLOSE LOG</button>
        </div>
    </div>

    <!-- Love Page Screen -->
    <div class="screen love-screen" id="loveScreen">
        <div class="hearts-bg" id="heartsBg"></div>
        <div class="love-container" style="position: relative; z-index: 1;">
            <h1 class="love-title">💕 For My Love 💕</h1>

            <div class="flower-container">
                <span class="flower">🌹</span>
                <span class="flower">🌸</span>
                <span class="flower">🌷</span>
                <span class="flower">🌺</span>
                <span class="flower">🌻</span>
            </div>

            <div class="love-message">
                You are the most amazing person I have ever met, and every day with you feels like a gift.
                Your smile lights up my world and makes everything better, no matter how hard the day has been.
                I love the way you laugh, the way you care, and the way you make me feel like the luckiest person alive.
                Even in a world full of chaos, you are my peace, my home, and my safe place.
                I promise to always cherish you, support you, and love you with everything I have.
                You mean the world to me, and I am so grateful to have you in my life forever. 💖
            </div>

            <div class="flower-container">
                <span class="flower">💐</span>
                <span class="flower">🌼</span>
                <span class="flower">🥀</span>
                <span class="flower">🌾</span>
                <span class="flower">💮</span>
            </div>

            <button class="menu-btn pink" id="closeLovePage" style="margin-top: 30px;">💕 BACK TO GAME 💕</button>
        </div>
    </div>

    <script>
        // ========== SOUND SYSTEM ==========
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }

        function playSound(type) {
            if (!gameState.settings.sound) return;
            initAudio();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'win':
                    oscillator.frequency.setValueAtTime(523, audioCtx.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2); // G5
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.4);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'lose':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'spin':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200 + Math.random() * 400, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.05);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    break;
                case 'click':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.05);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    break;
                case 'critical':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(1100, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(1320, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'jackpot':
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.connect(gain);
                            gain.connect(audioCtx.destination);
                            osc.frequency.setValueAtTime(400 + i * 100, audioCtx.currentTime);
                            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                            osc.start(audioCtx.currentTime);
                            osc.stop(audioCtx.currentTime + 0.15);
                        }, i * 100);
                    }
                    break;
                case 'bonus':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(660, audioCtx.currentTime + 0.15);
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    exponentialDecay(gainNode, 0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
            }
        }

        // Helper function for exponential decay (replaces broken polyfill)
        function exponentialDecay(gainNode, value, endTime) {
            gainNode.gain.exponentialRampToValueAtTime(Math.max(value, 0.0001), endTime);
        }

        // ========== GAME STATE ==========
        const gameState = {
            chips: 1250,
            accessLevel: 'RECRUIT',
            currentBetType: 'double',
            currentBetAmount: 100,
            isPlaying: false,
            // Round state
            lastRoundResult: null,
            canOverclock: false,
            loadedDiceUsedThisRound: false,
            // NEW: Streak system
            winStreak: 0,
            maxStreak: 0,
            // NEW: Combo multiplier (decays over time)
            comboMultiplier: 1.0,
            lastWinTime: 0,
            // NEW: Daily bonus
            lastDailyBonus: null,
            dailyBonusStreak: 0,
            // NEW: Insurance
            insuranceEnabled: false,
            // NEW: Jackpot mode
            jackpotMode: false,
            // NEW: Total stats for achievements
            totalWins: 0,
            totalLosses: 0,
            totalChipsWon: 0,
            totalChipsLost: 0,
            biggestWin: 0,
            // NEW: Mystery box
            mysteryBoxAvailable: false,
            lastMysteryBox: null,
            // NEW: Achievements
            achievements: {},
            // NEW: Ultimate Meter (System Overload)
            ultimateMeter: 0,
            ultimateActive: false,
            // NEW: Heat Level (Dynamic Difficulty)
            heatLevel: 20,
            // NEW: Character Class
            selectedClass: 'gambler',
            // NEW: Run Stats (for end-of-run rewards)
            runWins: 0,
            runLosses: 0,
            runChipsEarned: 0,
            runMaxStreak: 0,
            runStartChips: 1250,
            // NEW: Rebirth System
            rebirthLevel: 0, // 0-9 rebirth tiers
            diceCount: 1, // 1-4 dice based on access level
            // NEW: Unlocked Classes
            unlockedClasses: ['gambler'],
            upgrades: {
                safetyNet: false,
                luckyCharm: false,
                doubleDown: false,
                vaultAnalyzer: false,
                luckyPenny: false,
                loadedDice: false
            },
            settings: {
                sound: true,
                binary: true,
                animations: true
            }
        };

        // ========== CHARACTER CLASSES ==========
        const CHARACTER_CLASSES = [
            {
                id: 'gambler',
                name: 'GAMBLER',
                icon: '🎰',
                ability: 'Balanced: Standard play with no bonuses or penalties',
                effect: { winBonus: 0, lossReduction: 0, ultimateBoost: 0 }
            },
            {
                id: 'hacker',
                name: 'NETRUNNER',
                icon: '💻',
                ability: '+10% win chance but ultimate charges 20% slower',
                effect: { winBonus: 0.10, lossReduction: 0, ultimateBoost: -0.2 }
            },
            {
                id: 'bruiser',
                name: 'BRUISER',
                icon: '💪',
                ability: 'Lose 25% less chips but win 10% less',
                effect: { winBonus: -0.10, lossReduction: 0.25, ultimateBoost: 0 }
            },
            {
                id: 'lucky',
                name: 'LUCKY CAT',
                icon: '🐱',
                ability: '+5% critical hit chance but 10% less base winnings',
                effect: { winBonus: -0.10, lossReduction: 0, critBonus: 0.05, ultimateBoost: 0 }
            },
            {
                id: 'surge',
                name: 'SURGE',
                icon: '⚡',
                ability: 'Ultimate charges 50% faster but starts with lower heat tolerance',
                effect: { winBonus: 0, lossReduction: 0, ultimateBoost: 0.5, heatPenalty: 10 }
            },
            {
                id: 'tank',
                name: 'FIREWALL',
                icon: '🛡️',
                ability: 'Heat builds 30% slower, perfect for long runs',
                effect: { winBonus: 0, lossReduction: 0, ultimateBoost: 0, heatReduction: 0.3 }
            },
            // NEW BUYABLE CLASSES
            {
                id: 'bot',
                name: 'AUTOMATON',
                icon: '🤖',
                cost: 10000,
                ability: 'Immune to Heat, but Ultimate charges 50% slower',
                effect: { heatImmunity: true, ultimateBoost: -0.5 }
            },
            {
                id: 'sniper',
                name: 'HIGH ROLLER',
                icon: '🎯',
                cost: 15000,
                ability: 'Triple bets pay 4x instead of 3x',
                effect: { tripleBonus: 1 }
            },
            {
                id: 'merchant',
                name: 'BROKER',
                icon: '⚖️',
                cost: 20000,
                ability: 'All Upgrades cost 20% less',
                effect: { upgradeDiscount: 0.2 }
            },
            {
                id: 'vampire',
                name: 'LEECH',
                icon: '🧛',
                cost: 25000,
                ability: 'Recover 10% of chips on every loss',
                effect: { lossRecovery: 0.1 }
            },
            {
                id: 'timekeeper',
                name: 'PRE-COG',
                icon: '⏳',
                cost: 30000,
                ability: 'Overclock costs 50% less chips',
                effect: { overclockDiscount: 0.5 }
            },
            {
                id: 'titan',
                name: 'JUGGERNAUT',
                icon: '🗿',
                cost: 40000,
                ability: 'Heat Capacity increased by 50%',
                effect: { heatCapacity: 1.5 }
            },
            {
                id: 'monk',
                name: 'ZEN',
                icon: '🧘',
                cost: 50000,
                ability: 'Streak bonuses are Doubled',
                effect: { streakBonusMult: 2 }
            },
            {
                id: 'cipher',
                name: 'GHOST',
                icon: '👻',
                cost: 75000,
                ability: '25% Chance to fully refund a loss',
                effect: { refundChance: 0.25 }
            },
            // NEW FREE CLASSES
            {
                id: 'glitch',
                name: 'GLITCH',
                icon: '👾',
                cost: 0,
                ability: '1% Chance for 10x Win Multiplier',
                effect: { winMultiplierChance: 0.01, winMultiplier: 10 }
            },
            {
                id: 'architect',
                name: 'ARCHITECT',
                icon: '📐',
                cost: 0,
                ability: 'Passive: +10% Chips on every win',
                effect: { passiveWinBonus: 0.1 }
            },
            // NEW OP CLASS (Streak Reward)
            {
                id: 'sovereign',
                name: 'SOVEREIGN',
                icon: '👑',
                cost: 0,
                ability: 'THE HOUSE EDGE: 2x Winnings, No Heat, 50% Refund on Loss',
                effect: { winMultiplier: 2, heatImmunity: true, refundChance: 0.5 }
            }
        ];

        // ========== MAP SYSTEM ==========
        const MAPS = [
            { id: 'default', name: 'NEON CITY', desc: 'Standard Operations', class: '' },
            { id: 'cyber', name: 'CYBER DISTRICT', desc: 'High Tech Zone (+10% Chips)', class: 'cyber-theme' },
            { id: 'void', name: 'THE VOID', desc: 'High Risk Area (Mystery Box Chance ++)', class: 'void-theme' }
        ];

        // ========== UPDATE LOG DATA ==========
        const UPDATE_LOG = [
            {
                version: '2.1',
                date: '2026-01-30',
                title: 'THE PROTON UPDATE',
                changes: [
                    'REBIRTH SYSTEM: Reset at Admin level for permanent +5% win chance!',
                    'NEW CLASSES: 8 new buyable classes including Bot, Sniper, and Vampire.',
                    'MULTI-DICE: Dice count now scales with your Access Level.',
                    'BALANCE: Loaded Dice now has a 25% success chance (was 100%).',
                ]
            },
            {
                version: '2.0',
                date: '2026-01-20',
                title: 'DOUBLE DOWN & EVENTS',
                changes: [
                    'Added Love Page for special events.',
                    'Improved mobile layout responsiveness.',
                    'Added System Overload ultimate mechanic.'
                ]
            }
        ];

        function renderUpdateLog() {
            const list = document.getElementById('updatesList');
            if (!list) return;

            list.innerHTML = UPDATE_LOG.map(update => `
                <div style="margin-bottom: 20px; border-bottom: 1px solid var(--text-dim); padding-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="color: var(--cyan); font-family: 'Orbitron'; font-size: 16px;">v${update.version}</span>
                        <span style="color: var(--text-dim); font-size: 12px;">${update.date}</span>
                    </div>
                    <div style="color: var(--gold); font-weight: bold; margin-bottom: 8px;">${update.title}</div>
                    <ul style="padding-left: 20px; color: var(--text); font-size: 12px; line-height: 1.6;">
                        ${update.changes.map(change => `<li>${change}</li>`).join('')}
                    </ul>
                </div>
            `).join('');
        }

        // ========== HEAT LEVEL THRESHOLDS ==========
        const HEAT_LEVELS = [
            { name: 'ICE', threshold: 0, class: 'ice', difficultyMod: 0.05 },     // +5% win chance
            { name: 'COOL', threshold: 20, class: 'cool', difficultyMod: 0 },     // Normal
            { name: 'WARM', threshold: 40, class: 'warm', difficultyMod: -0.05 }, // -5% win chance
            { name: 'HOT', threshold: 60, class: 'hot', difficultyMod: -0.10 },   // -10% win chance
            { name: 'INFERNO', threshold: 80, class: 'inferno', difficultyMod: -0.15 } // -15% win chance
        ];

        // ========== ACHIEVEMENTS ==========
        const ACHIEVEMENTS = [
            { id: 'firstWin', name: 'FIRST BLOOD', desc: 'Win your first bet', icon: '🎯', check: () => gameState.totalWins >= 1 },
            { id: 'streak5', name: 'HOT STREAK', desc: 'Get a 5 win streak', icon: '🔥', check: () => gameState.maxStreak >= 5 },
            { id: 'streak10', name: 'UNSTOPPABLE', desc: 'Get a 10 win streak', icon: '⚡', check: () => gameState.maxStreak >= 10 },
            { id: 'bigWin', name: 'BIG WINNER', desc: 'Win 1,000+ in one bet', icon: '💰', check: () => gameState.biggestWin >= 1000 },
            { id: 'megaWin', name: 'MEGA JACKPOT', desc: 'Win 5,000+ in one bet', icon: '💎', check: () => gameState.biggestWin >= 5000 },
            { id: 'hacker', name: 'HACKER', desc: 'Reach Hacker level', icon: '💻', check: () => gameState.chips >= 5000 },
            { id: 'elite', name: 'ELITE', desc: 'Reach Elite level', icon: '🎖️', check: () => gameState.chips >= 25000 },
            { id: 'admin', name: 'ADMIN ACCESS', desc: 'Reach Admin level', icon: '👑', check: () => gameState.chips >= 100000 },
            { id: 'survivor', name: 'SURVIVOR', desc: 'Use Safety Net', icon: '🛡️', check: () => gameState.achievements.survivorTriggered },
            { id: 'flipper', name: 'FATE FLIPPER', desc: 'Use Loaded Dice to win', icon: '🎲', check: () => gameState.achievements.loadedDiceWin },
            { id: 'collector', name: 'COLLECTOR', desc: 'Buy 4 upgrades', icon: '📦', check: () => Object.values(gameState.upgrades).filter(v => v).length >= 4 },
            { id: 'dedicated', name: 'DEDICATED', desc: 'Claim 7 daily bonuses', icon: '📅', check: () => gameState.dailyBonusStreak >= 7 },
        ];

        const UPGRADES = [
            { id: 'safetyNet', name: 'SAFETY NET', desc: 'Keep 100 chips on total loss', cost: 2000 },
            { id: 'luckyPenny', name: 'LUCKY PENNY', desc: 'Min roll increased from 1 to 2', cost: 3000 },
            { id: 'luckyCharm', name: 'LUCKY CHARM', desc: '+5% win chance on all bets', cost: 5000 },
            { id: 'loadedDice', name: 'LOADED DICE', desc: 'Once per round, 25% chance to flip result', cost: 8000 },
            { id: 'doubleDown', name: 'DOUBLE DOWN', desc: 'Unlock Double Down option after win', cost: 10000 },
            { id: 'vaultAnalyzer', name: 'VAULT ANALYZER', desc: 'See outcome probability hints', cost: 15000 }
        ];

        const OVERCLOCK_COST = 50;
        const COMBO_DECAY_TIME = 10000; // 10 seconds
        const CRITICAL_HIT_CHANCE = 0.05; // 5% chance for 5x payout
        const CURRENT_VERSION = '2.1';

        // Base access levels (before rebirth scaling)
        const BASE_ACCESS_LEVELS = [
            { name: 'RECRUIT', threshold: 0 },
            { name: 'HACKER', threshold: 5000 },
            { name: 'ELITE', threshold: 25000 },
            { name: 'ADMIN', threshold: 100000 }
        ];

        // Get access levels scaled by rebirth level
        function getAccessLevels() {
            // Harder scaling: 2.5x per level (was 1.5x)
            const multiplier = Math.pow(2.5, gameState.rebirthLevel);
            return BASE_ACCESS_LEVELS.map(level => ({
                name: level.name,
                threshold: level.name === 'RECRUIT' ? 0 : Math.floor(level.threshold * multiplier)
            }));
        }

        // For backward compatibility, use dynamic getter
        const ACCESS_LEVELS = BASE_ACCESS_LEVELS;

        // DOM Elements
        const screens = {
            menu: document.getElementById('menuScreen'),
            game: document.getElementById('gameScreen'),
            howToPlay: document.getElementById('howToPlayScreen'),
            upgradeShop: document.getElementById('upgradeShopScreen'),
            settings: document.getElementById('settingsScreen'),
            gameOver: document.getElementById('gameOverScreen'),
            achievements: document.getElementById('achievementsScreen'),
            classSelect: document.getElementById('classSelectScreen'),
            love: document.getElementById('loveScreen'),
            updates: document.getElementById('updatesScreen'),
            mapSelect: document.getElementById('mapSelectScreen')
        };

        // ========== HELPER FUNCTIONS ==========
        function formatNumber(num) {
            if (num >= 1000000000) return (num / 1000000000).toFixed(1) + 'b';
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'm';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'k';
            return num.toLocaleString();
        }

        // ========== INITIALIZE ==========
        function init() {
            loadGame();
            createBinaryBackground();
            renderDice(); // NEW: Dynamic dice rendering
            updateDisplay();
            renderUpgrades();
            renderAchievements();
            renderClasses();
            setupEventListeners();
            startClock();
            checkDailyBonus();
            checkMysteryBox();
            updateStreakDisplay();
            updateComboDisplay();
            updateUltimateMeter();
            updateHeatDisplay();
            updateClassDisplay();
            updateClassDisplay();
            updateRebirthDisplay(); // NEW: Rebirth badge
            createFloatingHearts();

            // Apply saved map theme
            if (gameState.currentMap) {
                const map = MAPS.find(m => m.id === gameState.currentMap);
                if (map && map.class) document.body.className = map.class;
            }

            // Auto-show updates if new version
            const lastVersion = localStorage.getItem('lastSeenVersion');
            if (lastVersion !== CURRENT_VERSION) {
                renderUpdateLog();
                showScreen('updates');
                localStorage.setItem('lastSeenVersion', CURRENT_VERSION);
            }
        }

        // Binary Background
        function createBinaryBackground() {
            const bg = document.getElementById('binaryBg');
            bg.innerHTML = '';

            for (let i = 0; i < 20; i++) {
                const column = document.createElement('div');
                column.className = 'binary-column';
                column.style.left = (i * 5) + '%';
                column.style.animationDuration = (10 + Math.random() * 15) + 's';
                column.style.animationDelay = (Math.random() * 10) + 's';

                let binary = '';
                for (let j = 0; j < 50; j++) {
                    binary += Math.random() > 0.5 ? '1' : '0';
                    if (j % 8 === 7) binary += '<br>';
                }
                column.innerHTML = binary;
                bg.appendChild(column);
            }
        }

        // Clock
        function startClock() {
            function updateClock() {
                const now = new Date();
                const time = now.toLocaleTimeString('en-US', { hour12: false });
                document.getElementById('timeDisplay').textContent = `TIME: ${time}`;
            }
            updateClock();
            setInterval(updateClock, 1000);

            // Check combo decay every second
            setInterval(updateComboDecay, 1000);
        }

        // ========== MULTI-DICE SYSTEM ==========

        // Calculate how many dice based on access level
        function getDiceCountForLevel() {
            const levels = getAccessLevels();
            let diceCount = 1;

            // RECRUIT = 1 die, HACKER = 2 dice, ELITE = 3 dice, ADMIN = 4 dice
            if (gameState.chips >= levels[3].threshold) diceCount = 4; // ADMIN
            else if (gameState.chips >= levels[2].threshold) diceCount = 3; // ELITE
            else if (gameState.chips >= levels[1].threshold) diceCount = 2; // HACKER
            else diceCount = 1; // RECRUIT

            return diceCount;
        }

        // Render dice dynamically based on dice count
        function renderDice() {
            const container = document.getElementById('diceContainer');
            if (!container) return;

            const diceCount = getDiceCountForLevel();
            gameState.diceCount = diceCount;

            // Get size class
            let sizeClass = 'single';
            if (diceCount === 2) sizeClass = 'dice-2';
            else if (diceCount === 3) sizeClass = 'dice-3';
            else if (diceCount >= 4) sizeClass = 'dice-4';

            // Calculate dice half for CSS transforms
            const diceHalfMap = { 'single': '75px', 'dice-2': '60px', 'dice-3': '50px', 'dice-4': '40px' };
            const diceHalf = diceHalfMap[sizeClass];

            container.innerHTML = '';

            for (let i = 0; i < diceCount; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = `dice-wrapper ${sizeClass}`;
                wrapper.style.setProperty('--dice-half', diceHalf);

                const scene = document.createElement('div');
                scene.className = 'dice-scene';
                scene.id = `diceScene${i}`;
                scene.style.setProperty('--dice-half', diceHalf);

                // Create all 6 faces
                const faces = [
                    { class: 'front', value: 1, pips: 1 },
                    { class: 'back', value: 6, pips: 6 },
                    { class: 'right', value: 3, pips: 3 },
                    { class: 'left', value: 4, pips: 4 },
                    { class: 'top', value: 2, pips: 2 },
                    { class: 'bottom', value: 5, pips: 5 }
                ];

                faces.forEach(face => {
                    const faceEl = document.createElement('div');
                    faceEl.className = `dice-face ${face.class}`;
                    faceEl.setAttribute('data-value', face.value);

                    for (let p = 0; p < face.pips; p++) {
                        const pip = document.createElement('div');
                        pip.className = `pip pip-${face.value}`;
                        faceEl.appendChild(pip);
                    }

                    scene.appendChild(faceEl);
                });

                wrapper.appendChild(scene);
                container.appendChild(wrapper);
            }
        }

        // ========== REBIRTH SYSTEM ==========

        // Update rebirth display badge
        function updateRebirthDisplay() {
            const badge = document.getElementById('rebirthBadge');
            const starsContainer = document.getElementById('rebirthStars');

            if (!badge || !starsContainer) return;

            if (gameState.rebirthLevel > 0) {
                badge.classList.remove('hidden');

                // Generate stars (filled for achieved, empty for remaining)
                let starsHTML = '';
                for (let i = 1; i <= 9; i++) {
                    if (i <= gameState.rebirthLevel) {
                        starsHTML += '<span class="rebirth-star">★</span>';
                    } else {
                        starsHTML += '<span class="rebirth-star empty">☆</span>';
                    }
                }
                starsContainer.innerHTML = starsHTML;
            } else {
                badge.classList.add('hidden');
            }
        }

        // Check if vault break is available and update button
        function updateVaultBreakButton() {
            const btn = document.getElementById('vaultBreakBtn');
            if (!btn) return;

            const levels = getAccessLevels();
            const adminThreshold = levels[3].threshold;

            // Show vault break button at ADMIN level (and if not at max rebirth)
            if (gameState.chips >= adminThreshold && gameState.rebirthLevel < 9) {
                btn.classList.add('show');
            } else {
                btn.classList.remove('show');
            }
        }

        // Break into vault and rebirth
        function breakIntoVault() {
            if (gameState.rebirthLevel >= 9) {
                showToast('🏆 Maximum rebirth level reached!');
                return;
            }

            const levels = getAccessLevels();
            if (gameState.chips < levels[3].threshold) {
                showToast('⚠️ Must reach ADMIN level to break into vault!');
                return;
            }

            // Show vault break animation
            const effect = document.getElementById('vaultBreakEffect');
            effect.classList.add('active');

            playSound('jackpot');
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 60);
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6600', 40);
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff3366', 30);

            setTimeout(() => {
                effect.classList.remove('active');

                // Increment rebirth level
                gameState.rebirthLevel++;

                // Reset chips and heat
                gameState.chips = 1250;
                gameState.heatLevel = 20;

                // NEW: Reset Upgrades for harder challenge
                gameState.upgrades = {
                    safetyNet: false,
                    luckyCharm: false,
                    doubleDown: false,
                    vaultAnalyzer: false,
                    luckyPenny: false,
                    loadedDice: false
                };

                // Reset run stats
                gameState.runWins = 0;
                gameState.runLosses = 0;
                gameState.runChipsEarned = 0;
                gameState.runMaxStreak = 0;
                gameState.runStartChips = 1250;

                // Show toast with new level requirement
                const newLevels = getAccessLevels();
                showToast(`🔥 REBIRTH ${gameState.rebirthLevel}/9! Upscaling Difficulty... Next ADMIN: ${newLevels[3].threshold.toLocaleString()}`);

                // Update everything
                renderDice();
                renderUpgrades(); // Re-render upgrades as they are reset
                updateDisplay();
                updateRebirthDisplay();
                updateVaultBreakButton();
                updateHeatDisplay();
                checkAchievements();
                saveGame();
            }, 2000);
        }

        // Get rebirth win bonus (5% per rebirth level)
        function getRebirthWinBonus() {
            return gameState.rebirthLevel * 0.05;
        }

        // ========== NEW FEATURE FUNCTIONS ==========

        // Streak System
        function updateStreakDisplay() {
            const streakValue = document.getElementById('streakValue');
            streakValue.textContent = gameState.winStreak + '🔥';
            if (gameState.winStreak >= 5) {
                streakValue.classList.add('hot');
            } else {
                streakValue.classList.remove('hot');
            }
        }

        function onWinStreak() {
            gameState.winStreak++;
            if (gameState.winStreak > gameState.maxStreak) {
                gameState.maxStreak = gameState.winStreak;
            }
            updateStreakDisplay();

            // CHECK FOR SOVEREIGN UNLOCK (100 Streak)
            if (gameState.winStreak >= 100 && !gameState.unlockedClasses.includes('sovereign')) {
                gameState.unlockedClasses.push('sovereign');
                showToast('👑 SOVEREIGN CLASS UNLOCKED! (100 Streak!)');
                saveGame();
            }
        }

        function onLoseStreak() {
            gameState.winStreak = 0;
            updateStreakDisplay();
        }

        // Combo System
        function updateComboDisplay() {
            const comboValue = document.getElementById('comboValue');
            comboValue.textContent = 'x' + gameState.comboMultiplier.toFixed(1);
        }

        function updateComboDecay() {
            const now = Date.now();
            const timeSinceWin = now - gameState.lastWinTime;

            if (gameState.comboMultiplier > 1.0 && timeSinceWin > COMBO_DECAY_TIME) {
                gameState.comboMultiplier = Math.max(1.0, gameState.comboMultiplier - 0.1);
                updateComboDisplay();
            }
        }

        function applyComboBonus() {
            gameState.lastWinTime = Date.now();
            gameState.comboMultiplier = Math.min(3.0, gameState.comboMultiplier + 0.2);
            updateComboDisplay();
        }

        // ========== ULTIMATE METER (SYSTEM OVERLOAD) ==========
        function updateUltimateMeter() {
            const fill = document.getElementById('ultimateFill');
            const percent = document.getElementById('ultimatePercent');
            const btn = document.getElementById('ultimateBtn');

            fill.style.width = gameState.ultimateMeter + '%';
            percent.textContent = Math.floor(gameState.ultimateMeter) + '%';

            if (gameState.ultimateMeter >= 100) {
                btn.disabled = false;
                btn.classList.add('ready');
            } else {
                btn.disabled = true;
                btn.classList.remove('ready');
            }
        }

        function chargeUltimateMeter(amount) {
            // Apply class bonus/penalty
            const classData = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            const boost = classData?.effect?.ultimateBoost || 0;
            const adjustedAmount = amount * (1 + boost);

            gameState.ultimateMeter = Math.min(100, gameState.ultimateMeter + adjustedAmount);
            updateUltimateMeter();
        }

        function activateSystemOverload() {
            if (gameState.ultimateMeter < 100 || gameState.ultimateActive) return;

            gameState.ultimateMeter = 0;
            gameState.ultimateActive = true;

            // Show effect
            const effect = document.getElementById('systemOverloadEffect');
            effect.style.display = 'block';
            setTimeout(() => {
                effect.style.display = 'none';
            }, 500);

            // Play sound
            playSound('jackpot');
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#00ffff', 50);
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff00ff', 50);

            showToast('⚡ SYSTEM OVERLOAD! Next 3 bets guaranteed WIN! ⚡');

            // Track overload uses
            gameState.overloadUsesRemaining = 3;

            updateUltimateMeter();
            saveGame();
        }

        // ========== HEAT LEVEL (DYNAMIC DIFFICULTY) ==========
        function updateHeatDisplay() {
            const fill = document.getElementById('heatFill');
            const text = document.getElementById('heatLevelText');

            fill.style.width = gameState.heatLevel + '%';

            // Find current heat level
            let currentHeat = HEAT_LEVELS[0];
            for (const level of HEAT_LEVELS) {
                if (gameState.heatLevel >= level.threshold) {
                    currentHeat = level;
                }
            }

            text.textContent = currentHeat.name;
            text.className = 'heat-level-text ' + currentHeat.class;
        }

        function adjustHeat(amount) {
            // Bot: Immunity to heat gain (but can still cool down)
            if (amount > 0 && getClassHeatImmunity()) return;

            // Apply class bonus/penalty
            const classData = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            const reduction = classData?.effect?.heatReduction || 0;

            // Titan: Increased capacity means slower heat build (amount is divided)
            const capacity = getClassHeatCapacity(); // default 1, Titan 1.5

            let adjustedAmount = amount;
            if (amount > 0) {
                adjustedAmount = (amount * (1 - reduction)) / capacity;
            }

            // Starting penalty for Surge class
            const penalty = classData?.effect?.heatPenalty || 0;

            gameState.heatLevel = Math.max(0, Math.min(100, gameState.heatLevel + adjustedAmount));
            updateHeatDisplay();
        }

        function getHeatDifficultyMod() {
            let currentHeat = HEAT_LEVELS[0];
            for (const level of HEAT_LEVELS) {
                if (gameState.heatLevel >= level.threshold) {
                    currentHeat = level;
                }
            }
            return currentHeat.difficultyMod;
        }

        // ========== CHARACTER CLASSES ==========
        function renderClasses() {
            const grid = document.getElementById('classGrid');
            if (!grid) return;
            grid.innerHTML = '';

            CHARACTER_CLASSES.forEach(cls => {
                const isUnlocked = !cls.cost || gameState.unlockedClasses.includes(cls.id);
                const isSelected = gameState.selectedClass === cls.id;
                const canAfford = gameState.chips >= (cls.cost || 0);

                const card = document.createElement('div');
                card.className = 'class-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' locked' : '');

                let costHtml = '';
                if (!isUnlocked) {
                    costHtml = `<div class="class-cost">${formatNumber(cls.cost)} <span style="font-size:12px">CHIPS</span></div>`;
                    if (!canAfford) card.classList.add('disabled');
                } else if (isSelected) {
                    costHtml = `<div class="class-cost" style="color:var(--cyan)">ACTIVE</div>`;
                }

                card.innerHTML = `
                    <div class="class-card-icon">${isUnlocked ? cls.icon : '🔒'}</div>
                    <div class="class-card-name">${cls.name}</div>
                    <div class="class-card-ability">${cls.ability}</div>
                    ${costHtml}
                `;
                card.onclick = () => selectClass(cls);
                grid.appendChild(card);
            });
        }

        function selectClass(cls) {
            console.log('Selecting class:', cls.id, 'Cost:', cls.cost, 'Current Class:', gameState.selectedClass);

            // Fix: Explicitly check for 0 cost (free classes) or ownership
            const isFree = cls.cost === 0 || cls.cost === undefined;
            const isOwned = gameState.unlockedClasses.includes(cls.id);

            if (isFree || isOwned) {
                gameState.selectedClass = cls.id;
                renderClasses();
                updateClassDisplay();
                playSound('click');
                saveGame();
                console.log('Class selected successfully');
            } else {
                // Try to buy
                if (gameState.chips >= cls.cost) {
                    if (confirm(`Unlock ${cls.name} class for ${cls.cost.toLocaleString()} chips?`)) {
                        gameState.chips -= cls.cost;
                        gameState.unlockedClasses.push(cls.id);
                        gameState.selectedClass = cls.id;

                        playSound('cash');
                        spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 50);
                        showToast(`🔓 Unlocked ${cls.name} Class!`);

                        updateDisplay();
                        renderClasses();
                        updateClassDisplay();
                        saveGame();
                        console.log('Class purchased and selected');
                    }
                } else {
                    playSound('error');
                    showToast('⚠️ Not enough chips to unlock!');
                }
            }
        }

        function updateClassDisplay() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            if (!cls) return;

            document.getElementById('classIcon').textContent = cls.icon;
            document.getElementById('className').textContent = cls.name;
            document.getElementById('classAbility').textContent = cls.ability;
        }

        function getClassWinBonus() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.winBonus || 0;
        }

        function getClassLossReduction() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.lossReduction || 0;
        }

        function getClassCritBonus() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.critBonus || 0;
        }

        function getClassTripleBonus() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.tripleBonus || 0;
        }

        function getClassUpgradeDiscount() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.upgradeDiscount || 0;
        }

        function getClassLossRecovery() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.lossRecovery || 0;
        }

        function getClassOverclockDiscount() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.overclockDiscount || 0;
        }

        function getClassHeatCapacity() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.heatCapacity || 1;
        }

        function getClassHeatImmunity() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.heatImmunity || false;
        }

        function getClassStreakBonusMult() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.streakBonusMult || 1;
        }

        function getClassRefundChance() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.refundChance || 0;
        }

        function getClassWinMultiplierChance() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.winMultiplierChance || 0;
        }

        function getClassWinMultiplier() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.winMultiplier || 1;
        }

        function getClassPassiveWinBonus() {
            const cls = CHARACTER_CLASSES.find(c => c.id === gameState.selectedClass);
            return cls?.effect?.passiveWinBonus || 0;
        }

        // ========== MAP SYSTEM LOGIC ==========
        function renderMaps() {
            const grid = document.getElementById('mapGrid');
            if (!grid) return;
            grid.innerHTML = '';

            MAPS.forEach(map => {
                const isSelected = gameState.currentMap === map.id;
                const el = document.createElement('div');
                el.className = `map-card ${map.id} ${isSelected ? 'selected' : ''}`;
                el.innerHTML = `
                    <div style="font-weight:bold; color:var(--cyan); margin-bottom:5px;">${map.name}</div>
                    <div style="font-size:12px; color:var(--text-dim);">${map.desc}</div>
                    ${isSelected ? '<div style="color:var(--green); font-size:12px; margin-top:5px;">ACTIVE</div>' : ''}
                `;
                el.onclick = () => selectMap(map.id);
                grid.appendChild(el);
            });
        }

        function selectMap(mapId) {
            gameState.currentMap = mapId;
            const map = MAPS.find(m => m.id === mapId);

            // Apply theme
            document.body.className = map.class || '';

            playSound('click');
            showToast(`🗺️ Travelling to ${map.name}...`);
            saveGame();
            renderMaps();
        }

        // ========== END OF RUN REWARDS ==========
        function startNewRun() {
            gameState.runWins = 0;
            gameState.runLosses = 0;
            gameState.runChipsEarned = 0;
            gameState.runMaxStreak = 0;
            gameState.runStartChips = gameState.chips;
            gameState.heatLevel = 20;
            updateHeatDisplay();
        }

        function showEndOfRunRewards() {
            // Calculate rewards
            const chipsEarned = Math.max(0, gameState.chips - gameState.runStartChips);
            const winRate = gameState.runWins + gameState.runLosses > 0
                ? Math.round(gameState.runWins / (gameState.runWins + gameState.runLosses) * 100)
                : 0;

            // Populate stats
            document.getElementById('endRunWins').textContent = gameState.runWins;
            document.getElementById('endRunLosses').textContent = gameState.runLosses;
            document.getElementById('endRunStreak').textContent = gameState.runMaxStreak;
            document.getElementById('endRunChips').textContent = formatNumber(chipsEarned);

            // Calculate rewards
            const rewards = [];

            // Base reward for playing
            const baseReward = Math.floor(gameState.runWins * 50);
            if (baseReward > 0) {
                rewards.push({ label: 'Win Bonus', value: '+' + formatNumber(baseReward) + ' chips' });
            }

            // Streak bonus
            if (gameState.runMaxStreak >= 5) {
                let streakBonus = gameState.runMaxStreak * 20;

                // Monk: Double streak bonus
                streakBonus *= getClassStreakBonusMult();

                // Bot: Half streak bonus
                if (gameState.selectedClass === 'bot') streakBonus = Math.floor(streakBonus * 0.5);

                rewards.push({ label: 'Streak Bonus (' + gameState.runMaxStreak + ')', value: '+' + formatNumber(streakBonus) + ' chips' });
                gameState.chips += streakBonus;
            }

            // Win rate bonus
            if (winRate >= 60) {
                const winRateBonus = Math.floor(winRate * 5);
                rewards.push({ label: 'Win Rate Bonus (' + winRate + '%)', value: '+' + formatNumber(winRateBonus) + ' chips' });
                gameState.chips += winRateBonus;
            }

            // Survivor bonus (made it back with chips)
            if (gameState.chips > gameState.runStartChips) {
                const profitBonus = Math.floor((gameState.chips - gameState.runStartChips) * 0.1);
                rewards.push({ label: 'Profit Bonus (10%)', value: '+' + formatNumber(profitBonus) + ' chips' });
                gameState.chips += profitBonus;
            }

            // Ultimate charge bonus
            const ultimateBonus = Math.min(25, gameState.runWins * 5);
            if (ultimateBonus > 0) {
                rewards.push({ label: 'Ultimate Charge', value: '+' + ultimateBonus + '%' });
                chargeUltimateMeter(ultimateBonus);
            }

            // Heat cooldown
            if (gameState.heatLevel > 20) {
                rewards.push({ label: 'Heat Cooldown', value: '-' + Math.floor(gameState.heatLevel * 0.3) + '%' });
                gameState.heatLevel = Math.max(20, gameState.heatLevel * 0.7);
                updateHeatDisplay();
            }

            // Render rewards
            const rewardsList = document.getElementById('endRunRewardsList');
            rewardsList.innerHTML = rewards.map(r => `
                <div class="reward-item">
                    <span class="reward-label">${r.label}</span>
                    <span class="reward-value">${r.value}</span>
                </div>
            `).join('');

            if (rewards.length === 0) {
                rewardsList.innerHTML = '<div class="reward-item"><span class="reward-label">No rewards - keep playing!</span></div>';
            }

            document.getElementById('endRunModal').classList.add('show');
            playSound('bonus');
        }

        function claimRunRewards() {
            document.getElementById('endRunModal').classList.remove('show');
            updateDisplay();
            saveGame();
            showScreen('menu');
        }

        // ========== LOVE PAGE FLOATING HEARTS ==========
        function createFloatingHearts() {
            const heartsBg = document.getElementById('heartsBg');
            if (!heartsBg) return;

            const hearts = ['❤️', '💕', '💖', '💗', '💓', '💘', '💝'];

            for (let i = 0; i < 20; i++) {
                const heart = document.createElement('div');
                heart.className = 'floating-heart';
                heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
                heart.style.left = Math.random() * 100 + '%';
                heart.style.animationDelay = Math.random() * 10 + 's';
                heart.style.animationDuration = (8 + Math.random() * 6) + 's';
                heartsBg.appendChild(heart);
            }
        }

        // Daily Bonus
        function checkDailyBonus() {
            const now = new Date();
            const today = now.toDateString();

            if (gameState.lastDailyBonus !== today) {
                // Calculate streak bonus
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);

                if (gameState.lastDailyBonus === yesterday.toDateString()) {
                    gameState.dailyBonusStreak++;
                } else if (gameState.lastDailyBonus !== null) {
                    gameState.dailyBonusStreak = 1;
                } else {
                    gameState.dailyBonusStreak = 1;
                }

                // Show daily bonus
                const bonusAmount = 500 + (gameState.dailyBonusStreak * 100);
                document.getElementById('dailyBonusAmount').textContent = '+' + bonusAmount;
                document.getElementById('dailyBonusBanner').classList.add('show');
            }
        }

        function claimDailyBonus() {
            const bonusAmount = 500 + (gameState.dailyBonusStreak * 100);
            gameState.chips += bonusAmount;
            gameState.lastDailyBonus = new Date().toDateString();

            document.getElementById('dailyBonusBanner').classList.remove('show');
            playSound('bonus');
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 30);
            showToast(`Daily Bonus: +${bonusAmount} chips! (Day ${gameState.dailyBonusStreak})`);

            updateDisplay();
            checkAchievements();
            saveGame();
        }

        // Achievements
        function renderAchievements() {
            const grid = document.getElementById('achievementsGrid');
            if (!grid) return;
            grid.innerHTML = '';

            ACHIEVEMENTS.forEach(ach => {
                const unlocked = ach.check();
                const item = document.createElement('div');
                item.className = 'achievement-item' + (unlocked ? ' unlocked' : '');
                item.innerHTML = `
                    <div class="achievement-icon">${ach.icon}</div>
                    <div class="achievement-name">${ach.name}</div>
                    <div class="achievement-desc">${ach.desc}</div>
                `;
                grid.appendChild(item);
            });
        }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(ach => {
                if (!gameState.achievements[ach.id] && ach.check()) {
                    gameState.achievements[ach.id] = true;
                    showToast(`🏆 Achievement Unlocked: ${ach.name}!`);
                    playSound('bonus');
                    spawnParticles(window.innerWidth / 2, 100, '#ffd700', 20);
                }
            });
            renderAchievements();
        }

        // Critical Hit System
        function checkCriticalHit() {
            return Math.random() < CRITICAL_HIT_CHANCE;
        }

        function showCriticalHit() {
            const critEl = document.getElementById('criticalHit');
            critEl.style.display = 'block';
            playSound('critical');

            setTimeout(() => {
                critEl.style.display = 'none';
            }, 1000);
        }

        // Particle Effects
        function spawnParticles(x, y, color, count = 20) {
            if (!gameState.settings.animations) return;

            const container = document.getElementById('particles');
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = (x + (Math.random() - 0.5) * 100) + 'px';
                particle.style.top = y + 'px';
                particle.style.background = color;
                particle.style.animationDuration = (1 + Math.random()) + 's';
                particle.style.animationDelay = (Math.random() * 0.3) + 's';
                container.appendChild(particle);

                setTimeout(() => particle.remove(), 2000);
            }
        }

        // Floating Text
        function showFloatingText(x, y, text, color) {
            if (!gameState.settings.animations) return;

            const floater = document.createElement('div');
            floater.className = 'floating-text';
            floater.textContent = text;
            floater.style.left = x + 'px';
            floater.style.top = y + 'px';
            floater.style.color = color;
            floater.style.fontSize = '24px';
            document.body.appendChild(floater);

            setTimeout(() => floater.remove(), 1500);
        }

        // Toast Notifications
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Mystery Box
        function checkMysteryBox() {
            const now = Date.now();
            const hoursSinceLastBox = gameState.lastMysteryBox ?
                (now - gameState.lastMysteryBox) / (1000 * 60 * 60) : 24;

            if (hoursSinceLastBox >= 4) {
                gameState.mysteryBoxAvailable = true;
                document.getElementById('mysteryBox').style.display = 'flex';
            } else {
                document.getElementById('mysteryBox').style.display = 'none';
            }
        }

        function openMysteryBox() {
            if (!gameState.mysteryBoxAvailable) return;

            const rewards = [
                { type: 'chips', amount: 100, text: '+100 Chips!' },
                { type: 'chips', amount: 250, text: '+250 Chips!' },
                { type: 'chips', amount: 500, text: '+500 Chips!' },
                { type: 'chips', amount: 1000, text: '+1,000 Chips!' },
                { type: 'streak', amount: 3, text: '+3 Streak Bonus!' },
                { type: 'combo', amount: 0.5, text: '+0.5 Combo!' },
            ];

            const reward = rewards[Math.floor(Math.random() * rewards.length)];

            switch (reward.type) {
                case 'chips':
                    gameState.chips += reward.amount;
                    break;
                case 'streak':
                    gameState.winStreak += reward.amount;
                    updateStreakDisplay();
                    break;
                case 'combo':
                    gameState.comboMultiplier = Math.min(3.0, gameState.comboMultiplier + reward.amount);
                    updateComboDisplay();
                    break;
            }

            gameState.mysteryBoxAvailable = false;
            gameState.lastMysteryBox = Date.now();
            document.getElementById('mysteryBox').style.display = 'none';

            playSound('jackpot');
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#9933ff', 40);
            showToast('🎁 Mystery Box: ' + reward.text);

            updateDisplay();
            saveGame();
        }

        // Display Updates
        function updateDisplay() {
            document.getElementById('creditsDisplay').textContent = formatNumber(gameState.chips);

            const levels = getAccessLevels();

            // Update access level
            let currentLevel = levels[0];
            for (const level of levels) {
                if (gameState.chips >= level.threshold) {
                    currentLevel = level;
                }
            }
            gameState.accessLevel = currentLevel.name;
            document.getElementById('accessLevel').textContent = currentLevel.name;

            // Update progress bar
            const currentIndex = levels.findIndex(l => l.name === currentLevel.name);
            const nextLevel = levels[currentIndex + 1];

            if (nextLevel) {
                const progress = (gameState.chips - currentLevel.threshold) / (nextLevel.threshold - currentLevel.threshold);
                const totalProgress = (currentIndex + progress) / (levels.length - 1) * 100;
                document.getElementById('accessFill').style.width = totalProgress + '%';
            } else {
                document.getElementById('accessFill').style.width = '100%';
            }

            // Update access labels
            const labels = document.querySelectorAll('.access-label');
            labels.forEach((label, index) => {
                label.classList.toggle('current', levels[index].name === currentLevel.name);
                // Optional: Update label text to show new threshold hints if we wanted
            });

            // Check if dice count needs update
            const neededDice = getDiceCountForLevel();
            if (neededDice !== gameState.diceCount) {
                renderDice();
            }

            // Update bet buttons
            updateBetButtons();

            // Update vault break button availability
            updateVaultBreakButton();
        }

        function updateBetButtons() {
            document.querySelectorAll('.bet-amount-btn').forEach(btn => {
                const amount = btn.dataset.amount;
                if (amount === 'all') {
                    btn.disabled = gameState.chips <= 0;
                } else {
                    btn.disabled = gameState.chips < parseInt(amount);
                }
            });

            const currentBet = gameState.currentBetAmount === 'all' ? gameState.chips : gameState.currentBetAmount;
            document.getElementById('currentBetDisplay').textContent = currentBet.toLocaleString();

            const multiplier = gameState.currentBetType === 'triple' ? '3x' : '2x';
            document.getElementById('multiplierDisplay').textContent = multiplier;
        }

        // Screen Navigation
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => {
                if (screen) screen.classList.remove('active');
            });
            if (screens[screenName]) screens[screenName].classList.add('active');

            // NEW: Toggle Ultimate Meter (Hide unless in game)
            const ultMeter = document.getElementById('ultimateMeter');
            if (ultMeter) {
                // Only show in game screen
                if (screenName === 'game') {
                    ultMeter.style.display = 'block';
                    // Re-run update to ensure button state is correct
                    updateUltimateMeter();
                } else {
                    ultMeter.style.display = 'none';
                }
            }
        }

        // Upgrades
        function renderUpgrades() {
            const grid = document.getElementById('upgradeGrid');
            grid.innerHTML = '';

            const discount = getClassUpgradeDiscount();

            UPGRADES.forEach(upgrade => {
                const owned = gameState.upgrades[upgrade.id];
                const realCost = Math.floor(upgrade.cost * (1 - discount));
                const canAfford = gameState.chips >= realCost;

                const item = document.createElement('div');
                item.className = 'upgrade-item' + (owned ? ' owned' : '');
                item.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-cost">${owned ? 'OWNED' : formatNumber(realCost) + ' CHIPS'}</div>
                `;

                if (!owned && canAfford) {
                    item.onclick = () => buyUpgrade(upgrade);
                }

                grid.appendChild(item);
            });
        }

        function buyUpgrade(upgrade) {
            const discount = getClassUpgradeDiscount();
            const realCost = Math.floor(upgrade.cost * (1 - discount));

            if (gameState.chips >= realCost && !gameState.upgrades[upgrade.id]) {
                gameState.chips -= realCost;
                gameState.upgrades[upgrade.id] = true;
                updateDisplay();
                renderUpgrades();
                saveGame();
            }
        }

        // Game Logic - Generate roll with Lucky Penny support
        function generateRoll() {
            // FIX: Standard D6 Logic (1-6)
            // Lucky Penny now ensures minimum roll of 2 (so 2-6)
            const minRoll = gameState.upgrades.luckyPenny ? 2 : 1;
            const maxRoll = 6;
            return Math.floor(Math.random() * (maxRoll - minRoll + 1)) + minRoll;
        }

        // Calculate win based on current bet type
        function calculateResult() {
            let won = false;
            let finalValue = generateRoll();
            let bonusChance = gameState.upgrades.luckyCharm ? 0.05 : 0;

            // Add heat level modifier (dynamic difficulty)
            bonusChance += getHeatDifficultyMod();

            // Add class win bonus
            bonusChance += getClassWinBonus();

            // Add Rebirth Bonus (Perma-buff)
            bonusChance += getRebirthWinBonus();

            // Check for System Overload (guaranteed win)
            if (gameState.ultimateActive && gameState.overloadUsesRemaining > 0) {
                won = true;
                gameState.overloadUsesRemaining--;

                if (gameState.overloadUsesRemaining <= 0) {
                    gameState.ultimateActive = false;
                    showToast('⚡ System Overload depleted!');
                }

                // Set appropriate winning value
                switch (gameState.currentBetType) {
                    case 'double':
                        finalValue = Math.random() > 0.5 ? 4 : 5; // Win is 4, 5, 6
                        break;
                    case 'highlow':
                        finalValue = 5; // High win
                        break;
                    case 'triple':
                        finalValue = '★';
                        break;
                }

                return { won, finalValue };
            }

            // Standard Logic: Roll vs Bet Type
            switch (gameState.currentBetType) {
                case 'double':
                    // Standard: 50/50 win logic + bonuses
                    // Logic: Roll 4-6 is WIN, 1-3 is LOSE (Simulated by 50% + bonus)
                    won = Math.random() < (0.5 + bonusChance);

                    // Force the roll to match the result
                    if (won) {
                        // Ensure roll is 4, 5, or 6
                        if (finalValue <= 3) finalValue = Math.floor(Math.random() * 3) + 4;
                    } else {
                        // Ensure roll is 1, 2, or 3
                        if (finalValue >= 4) finalValue = Math.floor(Math.random() * 3) + 1;
                    }
                    break;

                case 'highlow':
                    // High: 4-6 wins. Low: 1-3 wins? 
                    // Wait, current UI logic implies High/Low is just a variant?
                    // Let's assume High/Low means:
                    // High (4-6) pays out? Or player CHOOSES High vs Low?
                    // The UI currently just has "Double", "High/Low", "Triple".
                    // Assuming "High/Low" button implies High Risk / Low Risk? 
                    // Or choosing range... 
                    // Existing logic was: won 50% time, result random.

                    // Let's clean this up:
                    // Treat 'double' as Standard Bet (Evens/Odds or High/Low implicit 50/50).
                    // Treat 'highlow' as High Risk?
                    // Let's make HighLow actually require High Roll (4,5,6).

                    // Strict D6 Logic:
                    won = finalValue >= 4;

                    // Apply bonus chance modification
                    if (!won && Math.random() < bonusChance) {
                        won = true;
                        finalValue = Math.floor(Math.random() * 3) + 4; // Force win
                    }
                    break;

                case 'triple':
                    // Hard Mode: Needs 3 of a kind (Triple) or Triple Yield?
                    // Legacy logic: 1/3 chance.
                    won = Math.random() < (0.33 + bonusChance);
                    if (won) finalValue = '★'; // Special symbol
                    break;
            }

            return { won, finalValue };
        }

        // Apply result to game state and UI
        function applyResult(won, finalValue, betAmount, isReroll = false) {
            const vaultDisplay = document.getElementById('vaultDisplay');
            const vaultValue = document.getElementById('vaultValue');
            const resultMessage = document.getElementById('resultMessage');

            vaultValue.textContent = finalValue;
            vaultDisplay.classList.remove('win', 'lose');
            resultMessage.classList.remove('show', 'win', 'lose');

            // Store for potential re-roll or flip
            gameState.lastRoundResult = { won, betAmount, finalValue };
            gameState.canOverclock = true;

            if (won) {
                // Check for critical hit (base 5% + class bonus)
                const critChance = CRITICAL_HIT_CHANCE + getClassCritBonus();
                const isCritical = Math.random() < critChance;

                // Base multiplier (2x or 3x) + Class Bonus (Sniper)
                let multiplier = (gameState.currentBetType === 'triple' ? 3 : 2) +
                    (gameState.currentBetType === 'triple' ? getClassTripleBonus() : 0);

                // Apply combo multiplier
                multiplier *= gameState.comboMultiplier;

                // Apply critical hit
                if (isCritical) {
                    multiplier *= 2.5; // Extra 2.5x on critical
                    showCriticalHit();
                }

                // Glitch Class: Chance for massive multiplier
                if (getClassWinMultiplierChance() > 0 && Math.random() < getClassWinMultiplierChance()) {
                    multiplier = getClassWinMultiplier(); // Sets to 10x
                    showToast('👾 GLITCH PROTOCOL EXECUTED: 10x PAYOUT!');
                    spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff00ff', 100);
                }

                let winnings = Math.floor(betAmount * multiplier);

                // Architect Class: Passive bonus on win
                if (getClassPassiveWinBonus() > 0) {
                    const extra = Math.floor(winnings * getClassPassiveWinBonus());
                    winnings += extra;
                }

                // MAP BONUS: Cyber District (+10%)
                if (gameState.currentMap === 'cyber') {
                    const mapBonus = Math.floor(winnings * 0.1);
                    winnings += mapBonus;
                }

                if (!isReroll) {
                    gameState.chips += winnings - betAmount;
                } else {
                    gameState.chips += winnings;
                }

                // Track stats
                gameState.totalWins++;
                gameState.totalChipsWon += winnings;
                if (winnings > gameState.biggestWin) {
                    gameState.biggestWin = winnings;
                }

                // Track run stats
                gameState.runWins++;
                gameState.runChipsEarned += winnings;
                if (gameState.winStreak > gameState.runMaxStreak) {
                    gameState.runMaxStreak = gameState.winStreak;
                }

                // Streak and combo bonuses
                onWinStreak();
                applyComboBonus();

                // Winning reduces heat (cooling off)
                adjustHeat(-5);

                vaultDisplay.classList.add('win');

                if (isCritical) {
                    resultMessage.textContent = `CRITICAL! +${formatNumber(winnings)} CHIPS!`;
                } else {
                    resultMessage.textContent = `+${formatNumber(winnings)} CHIPS!`;
                }
                resultMessage.classList.add('win', 'show');

                // Sound and particles
                playSound(isCritical ? 'critical' : 'win');
                spawnParticles(window.innerWidth / 2, window.innerHeight / 3,
                    isCritical ? '#ffd700' : '#00ff88', isCritical ? 40 : 20);

            } else {
                // Apply class loss reduction
                const lossReduction = getClassLossReduction();
                let actualLoss = Math.floor(betAmount * (1 - lossReduction));

                // Vampire: Recover percentage of loss
                const recovery = Math.floor(actualLoss * getClassLossRecovery());
                if (recovery > 0) {
                    showToast(`🧛 Vampire Draining: Recovered ${recovery} chips`);
                    actualLoss -= recovery;
                }

                // Cipher: Chance to refund fully
                if (Math.random() < getClassRefundChance()) {
                    showToast(`👻 GHOST PROTOCOL: Loss Refunded!`);
                    actualLoss = 0;
                }

                if (!isReroll) {
                    gameState.chips -= actualLoss;
                }

                // Track stats
                gameState.totalLosses++;
                gameState.totalChipsLost += actualLoss;

                // Track run stats
                gameState.runLosses++;

                // Reset streak
                onLoseStreak();

                // Losing increases heat (getting hot)
                adjustHeat(10);

                // Losing charges ultimate meter (comeback mechanic!)
                const chargeAmount = 10 + Math.floor(betAmount / 100) * 2;
                chargeUltimateMeter(chargeAmount);

                vaultDisplay.classList.add('lose');
                resultMessage.textContent = `-${actualLoss.toLocaleString()} CHIPS`;
                resultMessage.classList.add('lose', 'show');

                // Sound
                playSound('lose');

                // Check for game over
                if (gameState.chips <= 0) {
                    if (gameState.upgrades.safetyNet) {
                        gameState.chips = 100;
                        gameState.achievements.survivorTriggered = true;
                        resultMessage.textContent = 'SAFETY NET ACTIVATED! 100 CHIPS SAVED';
                        playSound('bonus');
                    } else {
                        setTimeout(() => {
                            showScreen('gameOver');
                        }, 1500);
                    }
                }
            }

            updateDisplay();
            updateSpecialButtons();
            checkAchievements();
            saveGame();
        }

        // Update Overclock and Loaded Dice button states
        function updateSpecialButtons() {
            const overclockBtn = document.getElementById('overclockBtn');
            const loadedDiceBtn = document.getElementById('loadedDiceBtn');

            // Overclock: available after a loss, costs chips
            const canAffordOverclock = gameState.chips >= OVERCLOCK_COST;
            const hasLostRound = gameState.lastRoundResult && !gameState.lastRoundResult.won;
            overclockBtn.disabled = !canAffordOverclock || !hasLostRound || gameState.isPlaying;

            // Loaded Dice: available if upgrade owned, not used this round, and round just finished
            const hasLoadedDice = gameState.upgrades.loadedDice;
            const canFlip = gameState.lastRoundResult && !gameState.loadedDiceUsedThisRound;
            loadedDiceBtn.disabled = !hasLoadedDice || !canFlip || gameState.isPlaying;
        }

        // 3D Dice Logic
        function getDiceRotation(value) {
            // value can be number 1-6 or symbols '✓', '✗', '★'
            // For symbols, we'll map them to faces for visual flair
            // ✓ -> 1 (Cyan), ✗ -> 5 (Red), ★ -> 6 (Purple)

            let targetFace = 1;

            if (typeof value === 'number') {
                targetFace = value;
                if (targetFace < 1) targetFace = 1;
                if (targetFace > 6) targetFace = 6;
            } else {
                if (value === '✓') targetFace = 1; // Success (Cyan)
                else if (value === '✗') targetFace = 5; // Fail (Red)
                else if (value === '★') targetFace = 6; // Triple (Purple)
                else targetFace = Math.floor(Math.random() * 6) + 1;
            }

            // Base rotations to show faces
            // 1: x0 y0
            // 6: x180 y0
            // 3: x0 y-90
            // 4: x0 y90
            // 2: x-90 y0
            // 5: x90 y0

            const rotations = {
                1: { x: 0, y: 0 },
                6: { x: 180, y: 0 },
                3: { x: 0, y: -90 },
                4: { x: 0, y: 90 },
                2: { x: -90, y: 0 },
                5: { x: 90, y: 0 }
            };

            // Add extra spins (multiples of 360) for effect
            const extraX = 720 + (Math.floor(Math.random() * 2) * 360);
            const extraY = 720 + (Math.floor(Math.random() * 2) * 360);

            const base = rotations[targetFace];
            return {
                x: base.x + extraX,
                y: base.y + extraY
            };
        }

        function rollDice(finalValue, callback) {
            // Apply to all dice scenes
            const diceScenes = document.querySelectorAll('.dice-scene');

            // Calculate target rotation based on the result
            const rotation = getDiceRotation(finalValue);

            diceScenes.forEach((diceScene, index) => {
                // Add slight random variation to each die's extra rotations so they don't look identical
                // We keep the base rotation same so they land on same face
                const variationX = Math.floor(Math.random() * 2) * 360;
                const variationY = Math.floor(Math.random() * 2) * 360;

                diceScene.style.setProperty('--final-x', (parseInt(rotation.x) + variationX) + 'deg');
                diceScene.style.setProperty('--final-y', (parseInt(rotation.y) + variationY) + 'deg');

                diceScene.classList.remove('win', 'lose');

                // Stagger start slightly
                setTimeout(() => {
                    diceScene.classList.add('rolling');
                }, index * 100);
            });

            playSound('spin');

            // Wait for full animation (2s + max stagger)
            setTimeout(() => {
                diceScenes.forEach(diceScene => {
                    diceScene.classList.remove('rolling');
                    // Lock the rotation at final
                    const finalX = diceScene.style.getPropertyValue('--final-x');
                    const finalY = diceScene.style.getPropertyValue('--final-y');
                    diceScene.style.transform = `rotateX(${finalX}) rotateY(${finalY})`;
                });

                if (callback) callback();
            }, 2000 + (diceScenes.length * 100));
        }

        function setDiceFace(value) {
            const diceScene = document.getElementById('diceScene');
            const rotation = getDiceRotation(value);

            diceScene.classList.remove('rolling');
            diceScene.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
        }

        // Game Logic - Play Round
        function playRound() {
            if (gameState.isPlaying) return;

            const betAmount = gameState.currentBetAmount === 'all' ? gameState.chips : gameState.currentBetAmount;
            if (betAmount > gameState.chips || betAmount <= 0) return;

            // Reset round state
            gameState.lastRoundResult = null;
            gameState.canOverclock = false;
            gameState.loadedDiceUsedThisRound = false;

            gameState.isPlaying = true;
            const resultMessage = document.getElementById('resultMessage');
            const playBtn = document.getElementById('playBtn');

            playBtn.disabled = true;
            resultMessage.classList.remove('show', 'win', 'lose');
            updateSpecialButtons();

            // Calculate result first
            const { won, finalValue } = calculateResult();

            // Start rolling animation targeting the result
            rollDice(finalValue, () => {
                applyResult(won, finalValue, betAmount);
                gameState.isPlaying = false;
                playBtn.disabled = false;
                updateSpecialButtons();
            });
        }

        // Overclock: Pay chips to re-roll
        function useOverclock() {
            const discount = getClassOverclockDiscount();
            const realCost = Math.floor(OVERCLOCK_COST * (1 - discount));

            if (!gameState.lastRoundResult || gameState.chips < realCost) return;
            if (gameState.isPlaying) return;

            const betAmount = gameState.lastRoundResult.betAmount;

            // Deduct overclock cost
            gameState.chips -= realCost;
            gameState.isPlaying = true;

            const playBtn = document.getElementById('playBtn');
            playBtn.disabled = true;

            // Calculate new result
            const { won, finalValue } = calculateResult();

            // Start rolling
            rollDice(finalValue, () => {
                applyResult(won, finalValue, betAmount, true);
                gameState.canOverclock = false;
                gameState.isPlaying = false;
                playBtn.disabled = false;
                updateSpecialButtons();
            });
        }

        // Loaded Dice: Flip the result
        function useLoadedDice() {
            if (!gameState.lastRoundResult || gameState.loadedDiceUsedThisRound) return;
            if (!gameState.upgrades.loadedDice) return;
            if (gameState.isPlaying) return;

            gameState.loadedDiceUsedThisRound = true;

            // NERF: 25% Chance to work
            const success = Math.random() < 0.25;

            if (!success) {
                playSound('error');
                showToast('🎲 Loaded Dice FAILED!');
                updateSpecialButtons();
                saveGame();
                return;
            }

            showToast('🎲 Loaded Dice SUCCESS! Result Flipped!');
            playSound('bonus');

            const { won, betAmount, finalValue } = gameState.lastRoundResult;

            // Reverse the previous result
            if (won) {
                // Was a win, now becomes a loss
                const multiplier = gameState.currentBetType === 'triple' ? 3 : 2;
                const winnings = betAmount * multiplier;
                gameState.chips -= winnings;
                gameState.chips -= betAmount;

                let newFinalValue = finalValue === '✓' ? '✗' : (finalValue === '★' ? '✗' : finalValue);

                // If number, pick a losing number
                if (typeof finalValue === 'number') {
                    // Start flip animation
                    const diceScene = document.getElementById('diceScene');
                    diceScene.style.transition = 'transform 0.5s ease';

                    // Simple flip to opposite side (7 - value)
                    const newValue = 7 - finalValue;
                    newFinalValue = newValue;

                    const rotation = getDiceRotation(newValue);
                    diceScene.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
                }

                setTimeout(() => applyResultUI(false, newFinalValue, betAmount), 500);

            } else {
                // Was a loss, now becomes a win!
                gameState.chips += betAmount;
                const multiplier = gameState.currentBetType === 'triple' ? 3 : 2;
                const winnings = betAmount * multiplier;
                gameState.chips += winnings - betAmount;

                let newFinalValue = finalValue === '✗' ? '✓' : '★';

                // If number, pick a winning number
                if (typeof finalValue === 'number') {
                    const diceScene = document.getElementById('diceScene');
                    diceScene.style.transition = 'transform 0.5s ease';

                    const newValue = 7 - finalValue;
                    newFinalValue = newValue;

                    const rotation = getDiceRotation(newValue);
                    diceScene.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
                }

                setTimeout(() => applyResultUI(true, newFinalValue, betAmount), 500);
            }

            gameState.lastRoundResult.won = !won;
            updateSpecialButtons();
            saveGame();
        }

        // UI-only result update for Loaded Dice flip
        function applyResultUI(won, finalValue, betAmount) {
            const diceScene = document.getElementById('diceScene');
            const resultMessage = document.getElementById('resultMessage');

            diceScene.classList.remove('win', 'lose');
            resultMessage.classList.remove('show', 'win', 'lose');

            if (won) {
                const multiplier = gameState.currentBetType === 'triple' ? 3 : 2;
                const winnings = betAmount * multiplier;
                diceScene.classList.add('win');
                resultMessage.textContent = `FLIPPED! +${winnings.toLocaleString()} CHIPS!`;
                resultMessage.classList.add('win', 'show');
            } else {
                diceScene.classList.add('lose');
                resultMessage.textContent = `FLIPPED! -${betAmount.toLocaleString()} CHIPS`;
                resultMessage.classList.add('lose', 'show');

                if (gameState.chips <= 0) {
                    if (gameState.upgrades.safetyNet) {
                        gameState.chips = 100;
                        resultMessage.textContent = 'SAFETY NET ACTIVATED! 100 CHIPS SAVED';
                    } else {
                        setTimeout(() => showScreen('gameOver'), 1500);
                    }
                }
            }
            updateDisplay();
        }

        // Event Listeners
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('startRunBtn').onclick = () => {
                playSound('click');
                startNewRun();
                showScreen('game');
            };
            document.getElementById('howToPlayBtn').onclick = () => { playSound('click'); showScreen('howToPlay'); };
            document.getElementById('upgradeShopBtn').onclick = () => {
                playSound('click');
                renderUpgrades();
                showScreen('upgradeShop');
            };
            document.getElementById('settingsBtn').onclick = () => { playSound('click'); showScreen('settings'); };

            // NEW: Achievements button
            document.getElementById('achievementsBtn').onclick = () => {
                playSound('click');
                renderAchievements();
                showScreen('achievements');
            };

            // NEW: Class Selection button
            document.getElementById('classSelectBtn').onclick = () => {
                playSound('click');
                renderClasses();
                showScreen('classSelect');
            };

            // NEW: Love Page button
            document.getElementById('lovePageBtn').onclick = () => {
                playSound('click');
                showScreen('love');
            };

            // NEW: Daily bonus claim
            document.getElementById('claimBonusBtn').onclick = claimDailyBonus;

            // NEW: Mystery box
            document.getElementById('mysteryBox').onclick = openMysteryBox;

            // NEW: Ultimate/System Overload button
            document.getElementById('ultimateBtn').onclick = activateSystemOverload;

            // NEW: Vault Break button
            document.getElementById('vaultBreakBtn').onclick = breakIntoVault;

            // NEW: End of Run rewards claim
            document.getElementById('claimRunRewardsBtn').onclick = claimRunRewards;

            // Close buttons
            document.getElementById('closeHowToPlay').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeUpgradeShop').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeSettings').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeAchievements').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeClassSelect').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeClassSelect').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeLovePage').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeUpdates').onclick = () => { playSound('click'); showScreen('menu'); };
            document.getElementById('closeMapSelect').onclick = () => { playSound('click'); showScreen('menu'); };

            // NEW: Updates button
            document.getElementById('updatesBtn').onclick = () => {
                renderUpdateLog();
                playSound('click');
                showScreen('updates');
            };

            // NEW: Map button
            document.getElementById('mapSelectBtn').onclick = () => {
                renderMaps();
                playSound('click');
                showScreen('mapSelect');
            };

            // Game buttons
            document.getElementById('backToMenuBtn').onclick = () => {
                // Show end of run rewards if player made progress
                if (gameState.runWins > 0 || gameState.runLosses > 0) {
                    showEndOfRunRewards();
                } else {
                    showScreen('menu');
                }
                // Reset round state when leaving
                gameState.lastRoundResult = null;
                gameState.canOverclock = false;
                gameState.loadedDiceUsedThisRound = false;
            };
            document.getElementById('playBtn').onclick = playRound;
            document.getElementById('overclockBtn').onclick = useOverclock;
            document.getElementById('loadedDiceBtn').onclick = useLoadedDice;
            document.getElementById('restartBtn').onclick = () => {
                gameState.chips = 1250;
                startNewRun();
                updateDisplay();
                saveGame();
                showScreen('menu');
            };

            // Bet type buttons
            document.querySelectorAll('.bet-type-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.bet-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.currentBetType = btn.dataset.type;
                    updateDisplay();
                };
            });

            // Bet amount buttons
            document.querySelectorAll('.bet-amount-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.bet-amount-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.currentBetAmount = btn.dataset.amount === 'all' ? 'all' : parseInt(btn.dataset.amount);
                    updateDisplay();
                };
            });

            // Settings toggles
            document.getElementById('toggleSound').onclick = function () {
                this.classList.toggle('active');
                gameState.settings.sound = this.classList.contains('active');
                saveGame();
            };

            document.getElementById('toggleBinary').onclick = function () {
                this.classList.toggle('active');
                gameState.settings.binary = this.classList.contains('active');
                document.getElementById('binaryBg').style.display = gameState.settings.binary ? 'block' : 'none';
                saveGame();
            };

            document.getElementById('toggleAnimations').onclick = function () {
                this.classList.toggle('active');
                gameState.settings.animations = this.classList.contains('active');
                saveGame();
            };

            document.getElementById('resetProgress').onclick = () => {
                if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                    localStorage.removeItem('neonDoubleDown');
                    location.reload();
                }
            };

            // Press any key to start
            document.addEventListener('keypress', () => {
                if (screens.menu.classList.contains('active')) {
                    showScreen('game');
                }
            });
        }

        // Save/Load
        function saveGame() {
            localStorage.setItem('neonDoubleDown', JSON.stringify({
                chips: gameState.chips,
                upgrades: gameState.upgrades,
                settings: gameState.settings,
                // NEW: Save all stats and features
                winStreak: gameState.winStreak,
                maxStreak: gameState.maxStreak,
                comboMultiplier: gameState.comboMultiplier,
                lastWinTime: gameState.lastWinTime,
                lastDailyBonus: gameState.lastDailyBonus,
                dailyBonusStreak: gameState.dailyBonusStreak,
                totalWins: gameState.totalWins,
                totalLosses: gameState.totalLosses,
                totalChipsWon: gameState.totalChipsWon,
                totalChipsLost: gameState.totalChipsLost,
                biggestWin: gameState.biggestWin,
                lastMysteryBox: gameState.lastMysteryBox,
                achievements: gameState.achievements,
                // NEW: Ultimate meter, heat level, and class
                ultimateMeter: gameState.ultimateMeter,
                heatLevel: gameState.heatLevel,
                selectedClass: gameState.selectedClass,
                // NEW: Rebirth data & Unlocked Classes
                rebirthLevel: gameState.rebirthLevel,
                // NEW: Rebirth data & Unlocked Classes
                rebirthLevel: gameState.rebirthLevel,
                unlockedClasses: gameState.unlockedClasses,
                currentMap: gameState.currentMap
            }));
        }

        function loadGame() {
            const saved = localStorage.getItem('neonDoubleDown');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.chips = data.chips || 1250;
                gameState.upgrades = data.upgrades || gameState.upgrades;
                gameState.settings = data.settings || gameState.settings;

                // NEW: Load all stats and features
                gameState.winStreak = data.winStreak || 0;
                gameState.maxStreak = data.maxStreak || 0;
                gameState.comboMultiplier = data.comboMultiplier || 1.0;
                gameState.lastWinTime = data.lastWinTime || 0;
                gameState.lastDailyBonus = data.lastDailyBonus || null;
                gameState.dailyBonusStreak = data.dailyBonusStreak || 0;
                gameState.totalWins = data.totalWins || 0;
                gameState.totalLosses = data.totalLosses || 0;
                gameState.totalChipsWon = data.totalChipsWon || 0;
                gameState.totalChipsLost = data.totalChipsLost || 0;
                gameState.biggestWin = data.biggestWin || 0;
                gameState.lastMysteryBox = data.lastMysteryBox || null;
                gameState.achievements = data.achievements || {};

                // NEW: Load ultimate meter, heat level, and class
                gameState.ultimateMeter = data.ultimateMeter || 0;
                gameState.heatLevel = data.heatLevel || 20;
                gameState.selectedClass = data.selectedClass || 'gambler';

                // NEW: Load rebirth data
                gameState.rebirthLevel = data.rebirthLevel || 0;
                gameState.unlockedClasses = data.unlockedClasses || ['gambler'];
                gameState.currentMap = data.currentMap || 'default';

                // Apply settings
                document.getElementById('toggleSound').classList.toggle('active', gameState.settings.sound);
                document.getElementById('toggleBinary').classList.toggle('active', gameState.settings.binary);
                document.getElementById('toggleAnimations').classList.toggle('active', gameState.settings.animations);
                document.getElementById('binaryBg').style.display = gameState.settings.binary ? 'block' : 'none';
            }
        }

        // Start the game
        init();
    </script>
</body>

</html>